import React, { useState, useEffect } from 'react';

// Sample data for testing (replace with actual data from s.data)
const sampleData = `
TASK [debug] *******************************************************************
ok: [144.70.1.48] => {
    "output.stdout_lines": [
        "Datacenter: B2BBILLING-EAST-1",
        "Status=Up/Down,",
        "/ State=Normal/Leaving/Joining/Moving/Stopped,",
        "UN 144.70.3.162 221.47 GiB 16 ? 71651c35-74db-4d93-9997-8fb39410f39c RAC2",
        "UN 144.70.3.162 221.27 GiB 16 ? 312435c27d0 RAC3",
        "Datacenter: B2BBILLING-WEST-2",
        "Status=Up/Down,",
        "/ State=Normal/Leaving/Joining/Moving/Stopped,",
        "UN 144.70.39.12 271.67 GiB 16 ? 4cf2c994-40c6-4d7b-80a8-797899c60a96 RAC3",
        "UN 144.70.39.13 245.64 GiB 16 ? 09919fbb-b7a8-40bc-90e7-d8ee7e3e3775 RAC2",
        "Note: Non-system keyspaces don't have the same replication settings.",
    ]
}
PLAY RECAP *********************************************************************
144.70.1.48               : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
`;

const TaskOutput = () => {
  const [parsedData, setParsedData] = useState([]);
  const [overallStatus, setOverallStatus] = useState('Loading...');

  // Function to parse the console output
  const parseConsoleOutput = (data) => {
    const lines = data.split('\n');
    const datacenters = [];
    let currentDatacenter = null;

    lines.forEach((line) => {
      line = line.trim();

      // Identify Datacenter
      if (line.startsWith('Datacenter:')) {
        currentDatacenter = {
          name: line.split(':')[1].trim(),
          nodes: []
        };
        datacenters.push(currentDatacenter);
      }
      // Identify Node Information
      else if (/^(UN|DN|\?)/.test(line) && currentDatacenter) {
        const parts = line.split(/\s+/);
        currentDatacenter.nodes.push({
          status: parts[0],
          address: parts[1],
          load: parts[2] + ' ' + parts[3],
          tokens: parts[4],
          owns: parts[5],
          hostId: parts[6],
          rack: parts[7]
        });
      }
      // Check for overall status in PLAY RECAP
      else if (line.includes('PLAY RECAP')) {
        const statusLine = lines[lines.indexOf(line) + 1];
        setOverallStatus(statusLine.includes('failed=0') ? 'Finished: SUCCESS' : 'Finished: FAILURE');
      }
    });

    setParsedData(datacenters);
  };

  // Use Effect to parse the data on component mount
  useEffect(() => {
    parseConsoleOutput(sampleData); // Replace with actual data (e.g., from s.data)
  }, []);

  return (
    <div style={{ padding: '20px' }}>
      <h2 style={{ textAlign: 'right' }}>{overallStatus}</h2>
      {parsedData.map((dc, dcIndex) => (
        <div key={dcIndex} style={{ marginBottom: '30px' }}>
          <h3>{dc.name}</h3>
          <table border="1" style={{ width: '100%', borderCollapse: 'collapse' }}>
            <thead>
              <tr>
                <th>Status</th>
                <th>Address</th>
                <th>Load</th>
                <th>Tokens</th>
                <th>Owns</th>
                <th>Host ID</th>
                <th>Rack</th>
              </tr>
            </thead>
            <tbody>
              {dc.nodes.map((node, nodeIndex) => (
                <tr key={nodeIndex}>
                  <td>{node.status}</td>
                  <td>{node.address}</td>
                  <td>{node.load}</td>
                  <td>{node.tokens}</td>
                  <td>{node.owns}</td>
                  <td>{node.hostId}</td>
                  <td>{node.rack}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ))}
    </div>
  );
};

export default TaskOutput;
Hereâ€™s the revised version with a clearer structure, introducing Recycle Bin Purge first and then explaining the Deep Link as a dedicated section:


---

Subject: ðŸš€ New Self-Serve Tool â€“ Recycle Bin Purge ðŸš€

Hello Team,

Exciting news! ðŸŽ‰
DB Ops just got more efficient! Weâ€™re thrilled to introduce a new addition to DB Ops Self-Serve Tools â€“ Recycle Bin Purge!


---

What is Recycle Bin Purge?

Recycle Bin Purge is a powerful self-serve tool designed to help you efficiently manage storage in your Oracle DB by purging unnecessary data from the Recycle Bin.
This helps in:

Optimizing Storage: Reclaim valuable space by clearing out unwanted data.

Boosting Performance: Improve database performance by removing clutter.

Streamlining Operations: Execute purges quickly and easily without needing specialized knowledge.



---

ðŸ”— Deep Link Integration â€“ How It Works

The Recycle Bin Purge tool is enhanced with a Deep Link from the Oracle Database Health Check Report. Hereâ€™s how it benefits you:

Smart Parameter Auto-Fill: Clicking the deep link pre-populates all required parametersâ€”no manual entry needed!

Easy Validation: Review and validate the parameters before confirming the purge.

One-Click Execution: Confirm and execute the purge with a single click, saving you time and effort.


This Deep Link integration ensures a seamless and efficient experience, making the purge process faster and more reliable.


---

Access the Tool:

ðŸ‘‰ Recycle Bin Purge â€“ Oracle Elixir Report

By clicking the link above, the Oracle Elixir report will open with all parameters pre-filled using the Deep Link from the Oracle Database Health Check Report. Validate the parameters and proceed with the purgeâ€”it's that easy!


---

We Value Your Feedback!

Weâ€™re committed to continuously improving our tools. After using the Recycle Bin Purge, please share your feedback at:

engineering-practice-db@verizon.com

vz-sre-db-eng-practice@verizon.com


Need Help?
Encountered an issue? Open a JIRA to PCT115, and our team will assist you.

Try the Recycle Bin Purge Tool Today and Experience the Power of Deep Link Integration!


---

Why This Version Works:

Clear Structure: First introduces the tool, then explains the Deep Link as a dedicated topic.

Focused Description: Gives a concise overview of the Recycle Bin Purge tool and its benefits.

Detailed Explanation of Deep Link: Clearly explains what the Deep Link does and how it simplifies the process.

Call to Action: Encourages users to try the tool and provide feedback.


Would you like any more adjustments or a different approach?













. I am writing to bring to your attention a discrepancy in my Form 16 issued for the [Financial Year]. Upon reviewing the document, I noticed that my name has been incorrectly mentioned, with my first name and last name interchanged.

Incorrect Name: [Incorrect Name as per Form 16]
Correct Name: [Correct Name as per Official Records]

I kindly request you to make the necessary corrections and reissue the updated Form 16 at the earliest. Please let me know if you require any additional documents or information to process this request.

I appreciate your prompt attention to this matter and look forward to your response.

Thank you for your assistance.

Best regards,




Output.push(
  <div style={{ color: "green", marginLeft: "10px", fontSize: "large", fontWeight: "780" }}>
    {message}
  </div>
);

Output.push(
  <table key={index} style={{ width: "100%", borderCollapse: "collapse", marginTop: "10px" }}>
    <thead>
      <tr>
        {keys.map((key) => (
          <th
            key={key}
            style={{
              border: "2px solid #ada",
              padding: "8px",
              backgroundColor: "#F2F2F2",
              color: "#625395",
              fontSize: "12px",
              textAlign: "left",
            }}
          >
            {key}
          </th>
        ))}
        <th>
          <input
            type="checkbox"
            onChange={(e) => {
              const isChecked = e.target.checked;
              group.rows.forEach((item) => {
                item.selected = isChecked;
              });
              setOutput([...Output]); // Re-render with updated selection
            }}
          />
        </th>
      </tr>
    </thead>
    <tbody>
      {group.rows.map((item, rowIndex) => (
        <tr key={rowIndex}>
          {keys.map((key) => (
            <td
              key={key}
              style={{
                border: "1px solid #ddd",
                padding: "8px",
                textAlign: "left",
              }}
            >
              {typeof item[key] === "number" ? item[key].toFixed(1) : item[key]}
            </td>
          ))}
          <td>
            <input
              type="checkbox"
              checked={item.selected || false}
              onChange={(e) => {
                item.selected = e.target.checked;
                setOutput([...Output]); // Re-render with updated selection
              }}
            />
          </td>
        </tr>
      ))}
    </tbody>
  </table>
);

// Single button to kill selected items
Output.push(
  <button
    className="btn btn-primary btn-block"
    onClick={() => {
      const selectedItems = group.rows.filter((item) => item.selected);
      selectedItems.forEach((item) => {
        if (!killedItems[item.SID]) {
          killProcess(item.SID);
          killedItems[item.SID] = true;
        }
      });
      setOutput([...Output]); // Re-render with updated state
    }}
  >
    Kill Selected
  </button>
);
Here's an updated email draft based on the details you provided:


---

Subject: Issue Accessing Stock Plan Option

Dear [Support Team/Relevant Department],

I am writing to report an issue I have been experiencing with my stock portal account. While my account is active and functional, I am unable to access the Stock Plan option. Specifically, when I try to click on it, the system displays the message:

"The system is currently unavailable. Please try to log in later."

This issue has persisted for the past two months, and despite waiting and retrying at different times, the problem remains unresolved.

Could you please look into this and provide a resolution? If you need any further details or account-specific information, I would be happy to provide them.

Thank you for your support, and I look forward to hearing from you soon.

Best regards,
[Your Full Name]
[Your Contact Information]
[Account ID/Details, if applicable]


---

Let me know if youâ€™d like any further adjustments!





router.post('/plan_change', async (req, res) => {
  let mainConnection;

  try {
    console.log('Request Body:', req.body);
    const { sqlId } = req.body;

    if (!sqlId) throw new Error('SQL ID is required');

    // Fetch rows from the main DB
    mainConnection = await oracledb.getConnection(dbConfig);
    const result = await mainConnection.execute('SELECT * FROM SREDBAUTO.DBNAMEGROUP');
    const rows = result.rows;

    if (!Array.isArray(rows)) throw new Error('Query result is not iterable');

    // Process each row dynamically
    const results = [];
    for (let i = 0; i < rows.length; i++) {
      const [HOST, SERVICE_NAME, PORT] = rows[i];
      console.log(`Processing Node ${i + 1}: Host=${HOST}, ServiceName=${SERVICE_NAME}, Port=${PORT}`);

      const nodeConnectionString = `${HOST}:${PORT}/${SERVICE_NAME}`;
      const nodeConfig = {
        user: 'oracle_user',
        password: 'oracle_password',
        connectString: nodeConnectionString,
      };

      let nodeConnection;
      try {
        // Connect to each node
        nodeConnection = await oracledb.getConnection(nodeConfig);
        const nodeResult = await nodeConnection.execute(`
          SELECT inst_id, sql_id, plan_hash_value, executions
          FROM gv$sql WHERE sql_id = :sqlId`, [sqlId]);
        results.push(...nodeResult.rows); // Add to results array
      } catch (err) {
        console.error(`Error processing node ${i + 1}:`, err.message);
      } finally {
        if (nodeConnection) {
          await nodeConnection.close();
        }
      }
    }

    // Return aggregated results
    res.status(200).json({ success: true, data: results });
  } catch (err) {
    console.error('Error:', err.message);
    res.status(500).json({ success: false, error: err.message });
  } finally {
    if (mainConnection) {
      await mainConnection.close();
    }
  }
});




const oracledb = require('oracledb');

router.post('/plan_change', async (req, res) => {
  try {
    console.log('Request body is:', req.body);
    const { sqlId } = req.body;

    if (!sqlId) {
      throw new Error('SQL ID is missing in the request body');
    }

    // Step 1: Establish initial database connection
    const connection = await oracledb.getConnection(dbConfig);

    // Step 2: Fetch rows and convert to JSON structure
    const result = await connection.execute('SELECT * FROM SREDBAUTO.DBNAMEGROUP');
    const rows = result.rows; // Extract rows from the query

    if (!Array.isArray(rows)) {
      throw new Error('Query result does not contain an iterable "rows" property');
    }

    // Convert rows to JSON objects for processing
    const jsonRows = rows.map(([HOST, SERVICE_NAME, PORT]) => ({
      HOST,
      SERVICE_NAME,
      PORT,
    }));

    console.log('Converted rows to JSON:', jsonRows);

    let concatenatedRows = []; // To store results from each host
    const nodeConnections = []; // Array to manage connections

    // Step 3: Loop through each host in JSON format and process sequentially
    for (let i = 0; i < jsonRows.length; i++) {
      const { HOST, SERVICE_NAME, PORT } = jsonRows[i];
      console.log(`Processing Node ${i + 1}: Hostname=${HOST}, ServiceName=${SERVICE_NAME}, Port=${PORT}`);

      // Construct connection string
      const nodeConnectionString = `${HOST}:${PORT}/${SERVICE_NAME}`;
      const nodeConfig = {
        user: 'oracle_NR_info_NP_user',
        password: 'oracle_NR_info_NP_password',
        connectString: nodeConnectionString,
      };

      try {
        // Establish a connection for this node
        const nodeConnection = await oracledb.getConnection(nodeConfig);
        nodeConnections.push(nodeConnection); // Track connection

        // Execute the query for this node
        const planHashResult = await nodeConnection.execute(`
          SELECT inst_id, sql_id, child_number AS child, plan_hash_value AS plan_hash, 
                 buffer_gets / executions AS "GETS/EXEC",
                 rows_processed / executions AS "ROWS/EXEC",
                 elapsed_time / executions / 1000 AS "ET/EXEC(Ms)",
                 ROUND(elapsed_time / executions / 1000, 2) AS "Elapsed Time (ms)"
          FROM gv$sql
          WHERE sql_id = :sqlId
            AND executions > 0
          ORDER BY inst_id, plan_hash_value
        `, [sqlId]);

        if (planHashResult && Array.isArray(planHashResult.rows)) {
          console.log(`Results for Node ${i + 1}: ${HOST}`);
          console.table(planHashResult.rows);

          // Concatenate results for this node
          concatenatedRows.push(...planHashResult.rows);
        }
      } catch (error) {
        console.error(`Error processing Node ${i + 1}:`, error.message);
      }
    }

    // Step 4: Close all connections
    for (let i = 0; i < nodeConnections.length; i++) {
      try {
        await nodeConnections[i].close();
        console.log(`Connection ${i + 1} closed.`);
      } catch (error) {
        console.error(`Error closing Connection ${i + 1}:`, error.message);
      }
    }

    // Step 5: Send the final response
    res.status(200).json({ success: true, data: concatenatedRows });
  } catch (err) {
    console.error('Caught exception:', err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});
<button className="btn btn-primary btn-block" type="submit" onClick={handleSubmit} style={{
  backgroundColor: "#007bff",
  color: "#fff",
  border: "none",
  padding: "10px 20px",
  fontSize: "16px",
  fontWeight: "bold",
  borderRadius: "5px",
  boxShadow: "0 5px #0056b3",
  transform: "translateY(-2px)",
  transition: "all 0.2s ease"
}} onMouseDown={(e) => e.target.style.transform = "translateY(0px)"}
onMouseUp={(e) => e.target.style.transform = "translateY(-2px)"}>
  <span>Submit</span>
</button>



function generateDataText(alertLogData) {
    let textContent = 'Alert Log Data\n\n';

    for (const entry of alertLogData) {
        if (entry["MESSAGE_TEXT"]) {
            // Apply the same filter: replace newlines with spaces and trim
            const messageContent = entry["MESSAGE_TEXT"].replace(/\n/g, ' ').trim();
            textContent += `Content: ${messageContent}\n\n`;
        }
    }

    // Create a Blob from the text content
    const blob = new Blob([textContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    // Create a link to download the file
    const link = document.createElement('a');
    link.href = url;
    link.download = 'alert_log_data.txt';

    // Programmatically click the link to trigger the download
    link.click();

    // Clean up by revoking the object URL
    URL.revokeObjectURL(url);
}

const fs = require('fs');

function generateDataText(alertLogData) {
    let textContent = 'Alert Log Data\n\n';

    for (const entry of alertLogData) {
        if (entry["MESSAGE_TEXT"]) {
            // Apply the same filter: replace newlines with spaces and trim
            const messageContent = entry["MESSAGE_TEXT"].replace(/\n/g, ' ').trim();
            textContent += `Content: ${messageContent}\n\n`;
        }
    }

    // Write the filtered content to a text file
    fs.writeFileSync('alert_log_data.txt', textContent, 'utf8');
    console.log('Data written to alert_log_data.txt');
}





Hereâ€™s a revised draft for the Word document, focusing on explaining the process and use case for the Slack AI bot to present to your manager and team. This version outlines the project steps, the use case, and the potential impact on the DB team, aiming to clarify the bot's value and implementation process.


---

[Word Document Draft: Slack AI Bot Proposal for DB Team]


---

Title: Proposal for Slack AI Bot to Support Database Development Team


---

1. Introduction

Purpose: This document proposes creating a Slack AI bot to streamline database-related queries, provide resource links, and deliver standardized best practices. The bot will enhance team productivity by reducing repetitive queries and enabling instant access to important information for Oracle, Cassandra, and other database technologies used by our team.

Target Audience: This proposal is intended for DB team members and stakeholders to understand the botâ€™s purpose, features, and the step-by-step process for development and deployment.


---

2. Use Case Overview

The Slack AI bot will serve as a real-time resource for developers, helping them with common questions, providing quick access to documentation, and assisting with database tasks. This reduces time spent searching for resources or waiting for responses from other team members.

Primary Use Cases:

Resource Lookup: Directs developers to the right setup, configuration, or troubleshooting documentation.

Best Practices Guidance: Provides standardized best practices for efficient database management.

Immediate Assistance: Quickly answers frequently asked questions, reducing repetitive queries to team leads.


Example Scenarios:

Oracle Setup Help: A developer asks for Oracle setup resources. The bot responds with setup links, saving time.

Cassandra Tuning Guidance: A developer needs tips on performance tuning in Cassandra. The bot offers best practices and links to in-depth resources.

SQL Query Optimization: For SQL-related queries, the bot provides best practices for query optimization, ensuring performance standards are met.



---

3. Proposed Development Process

This section details the high-level steps to build, test, and deploy the Slack AI bot:

Step 1: Define Project Scope and Gather Requirements

Identify Core Requirements: List common questions and tasks the bot should address based on feedback from the DB team.

Determine Key Resources: Collect documentation, best practices, and portal links that the bot will link to in responses.

Define Success Metrics: Establish metrics like response accuracy, response time, and user engagement to measure the bot's effectiveness.


Step 2: Set Up the Slack App

Create a New Slack App: Begin by creating the bot app on the Slack API portal.

Configure Permissions: Enable necessary permissions for message reading, writing, and custom commands.

Token and Authentication: Retrieve the OAuth token for authenticating the bot in our Slack workspace.


Step 3: Develop the Bot Logic

Define Command Triggers: Create commands like /db-guide Oracle setup and /db-guide SQL best practices.

Build Response Patterns: Use simple conditional logic to match user queries with responses, directing them to relevant links or documents.

Integrate with NLP (Optional): Implement NLP tools like spaCy or NLTK to allow the bot to handle varied phrasing for similar questions.


Step 4: Test the Bot with Real User Input

Run Tests with Sample Queries: Check that the bot responds accurately to various developer requests.

Gather Feedback: Get feedback from a group of developers to refine responses and add additional scenarios as needed.

Adjust and Fine-Tune: Based on testing feedback, refine responses and adjust logic as necessary.


Step 5: Deploy and Monitor Performance

Deployment Options: Choose a cloud platform (e.g., AWS Lambda or Heroku) for deploying the bot.

Monitor and Evaluate: Track metrics such as response accuracy, usage frequency, and feedback from developers to assess the botâ€™s effectiveness.

Iterate on User Feedback: Continue gathering feedback to improve the botâ€™s responses and add any new resources or FAQs as they arise.



---

4. Expected Impact

Implementing this Slack AI bot will have the following benefits for the DB team:

Efficiency Boost: By handling routine queries, the bot allows developers to spend less time searching for information and more time on core tasks.

Standardization: The bot delivers standardized responses, ensuring consistent adherence to best practices and policies across the team.

Scalability: The bot is easy to update and maintain, allowing it to evolve with the teamâ€™s needs over time.



---

5. Next Steps and Timeline

Week 1: Gather requirements and finalize scope. Identify core questions, documents, and best practices.

Weeks 2-3: Develop bot functionality, including setup on Slack API, defining commands, and initial bot logic.

Week 4: Testing phase with sample queries and initial user group feedback.

Week 5: Deployment, followed by ongoing monitoring and feedback collection for continued improvements.



---

6. Conclusion

The proposed Slack AI bot for the DB team aims to reduce delays in resource access, support adherence to best practices, and streamline routine query handling. With a structured development and testing process, we can build a valuable tool for the team that grows with our needs.


---

This structure should help clearly convey the botâ€™s purpose, development process, and benefits to your manager and team. Let me know if youâ€™d like to add or adjust any section further!


function generateHTMLTable(alertLogData, name) {
    let table = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Alert Log Table</title>
        <style>
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid black; padding: 8px; text-align: left; }
        </style>
    </head>
    <body>
        <h2>Alert Log Data for ${name}</h2>
        <table>
            <tr>
                <th>Content</th>
            </tr>
    `;

    // Check if alertLogData contains the key "MESSAGE_TEXT"
    if (alertLogData["MESSAGE_TEXT"]) {
        // Split the continuous string into individual messages based on "MESSAGE_TEXT: "
        const messages = alertLogData["MESSAGE_TEXT"].split(/MESSAGE_TEXT:\s*/).filter(Boolean);

        // Iterate through each message and add it as a row in the HTML table
        messages.forEach(messageContent => {
            table += `<tr><td>${messageContent.trim()}</td></tr>`;
        });
    }

    // Close the table and HTML structure
    table += `
        </table>
    </body>
    </html>
    `;

    return table;
}






// Function to fetch the alert log data and convert it to an HTML table
async function fetchAndDownloadAlertLogTable() {
    try {
        // Fetch the data from the backend
        const response = await axiosConfig.post('/DatabaseHealthCheckReports/db_alertlog', {
            env, cred_env, host_Name, dbName, portNum, noRecentLines
        });

        if (response.status === 200) {
            const alertLogData = response.data;  // This is the JSON data
            const tableHTML = generateHTMLTable(alertLogData);  // Generate the table HTML

            // Create a Blob with the table HTML and trigger the download as an .html file
            downloadAsHTMLFile(tableHTML, `${host_Name}_alertlog.html`);
        }
    } catch (error) {
        console.error("Error fetching data: ", error);
    }
}

// Function to generate an HTML table from JSON data
function generateHTMLTable(alertLogData) {
    // Begin HTML structure for the table
    let table = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Alert Log Table</title>
        <style>
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid black; padding: 8px; text-align: left; }
        </style>
    </head>
    <body>
        <h2>Alert Log Data for ${alertLogData.ALERTLOGHOST}</h2>
        <table>
            <tr>
                <th>Content</th>
            </tr>`;

    // Iterate through the alert log data
    for (const key in alertLogData) {
        if (key === "MESSAGE_TEXT") {
            // Clean up the message text by removing any unwanted prefixes or colons
            let messageContent = alertLogData[key].replace(/.*:\s*/, '').trim();  // Remove "MESSAGE_TEXT: " prefix and trim spaces
            
            // Add the cleaned message content to the table row
            table += `<tr><td>${messageContent}</td></tr>`;
        }
    }

    // Close the table and HTML structure
    table += `
        </table>
    </body>
    </html>`;

    return table;
}

// Function to download the table HTML as a file
function downloadAsHTMLFile(htmlContent, fileName) {
    // Create a Blob with the HTML content and the MIME type 'text/html'
    const blob = new Blob([htmlContent], { type: 'text/html' });
    
    // Create a link element to trigger the download
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.href = url;
    link.download = fileName;  // Specify the filename for download
    
    // Append the link to the body and trigger the click to download the file
    document.body.appendChild(link);
    link.click();
    
    // Clean up the link element after the download is triggered
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

// Trigger the download process
fetchAndDownloadAlertLogTable();





// Function to fetch the alert log data and convert it to an HTML table
async function fetchAndDownloadAlertLogTable() {
    try {
        // Fetch the data from the backend
        const response = await axiosConfig.post('/DatabaseHealthCheckReports/db_alertlog', {
            env, cred_env, host_Name, dbName, portNum, noRecentLines
        });

        if (response.status === 200) {
            const alertLogData = response.data;  // This is the JSON data
            const tableHTML = generateHTMLTable(alertLogData);  // Generate the table HTML

            // Create a Blob with the table HTML and trigger the download as an .html file
            downloadAsHTMLFile(tableHTML, `${host_Name}_alertlog.html`);
        }
    } catch (error) {
        console.error("Error fetching data: ", error);
    }
}

// Function to generate an HTML table from JSON data
function generateHTMLTable(alertLogData) {
    // Begin HTML structure for the table
    let table = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Alert Log Table</title>
        <style>
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid black; padding: 8px; text-align: left; }
        </style>
    </head>
    <body>
        <h2>Alert Log Data for ${alertLogData.ALERTLOGHOST}</h2>
        <table>
            <tr>
                <th>Parameter</th>
                <th>Message Text</th>
            </tr>`;

    // Iterate through the alert log data to fill in the rows
    for (const [key, value] of Object.entries(alertLogData)) {
        if (key === 'MESSAGE_TEXT') {
            for (const message of value) {
                table += `<tr><td>${key}</td><td>${message}</td></tr>`;
            }
        } else {
            table += `<tr><td>${key}</td><td>${value}</td></tr>`;
        }
    }

    // Close the table and HTML structure
    table += `
        </table>
    </body>
    </html>`;

    return table;
}

// Function to download the table HTML as a file
function downloadAsHTMLFile(htmlContent, fileName) {
    // Create a Blob with the HTML content and the MIME type 'text/html'
    const blob = new Blob([htmlContent], { type: 'text/html' });
    
    // Create a link element to trigger the download
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.href = url;
    link.download = fileName;  // Specify the filename for download
    
    // Append the link to the body and trigger the click to download the file
    document.body.appendChild(link);
    link.click();
    
    // Clean up the link element after the download is triggered
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

// Trigger the download process
fetchAndDownloadAlertLogTable();



const renderColumn = (columnData) => (
  <div style={{ width: '100%' }}>
    {columnData.map((group, index) => (
      <div key={index}>
        {/* Group Header */}
        <div style={headerStyle}>{group.header}</div>

        {/* Blockers: Highlight all rows */}
        {group.header === "Blockers" && group.rows.length > 0 && (
          <table style={tableStyle}>
            <thead>
              <tr>
                {Object.keys(group.rows[0]).map((key) => (
                  <th key={key} style={thStyle}>{key}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {group.rows.map((item, rowIndex) => (
                <tr key={rowIndex} style={{ backgroundColor: 'yellow' }}>
                  {Object.keys(item).map((key) => (
                    <td key={key} style={tdStyle}>{item[key]}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        )}

        {/* Long Runners: Highlight rows with Cur_SQL(min) > 5 */}
        {group.header === "Long Runners" && group.rows.length > 0 && (
          <table style={tableStyle}>
            <thead>
              <tr>
                {Object.keys(group.rows[0]).map((key) => (
                  <th key={key} style={thStyle}>{key}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {group.rows.map((item, rowIndex) => (
                <tr
                  key={rowIndex}
                  style={{
                    backgroundColor: parseFloat(item["Cur_SQL(min)"]) > 5 ? 'yellow' : 'transparent',
                  }}
                >
                  {Object.keys(item).map((key) => (
                    <td key={key} style={tdStyle}>{item[key]}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        )}

        {/* ASM Diskgroup Usage: Highlight rows where Used PCT >= 95 */}
        {group.header === "ASM Diskgroup Usage" && group.rows.length > 0 && (
          <table style={tableStyle}>
            <thead>
              <tr>
                {Object.keys(group.rows[0]).map((key) => (
                  <th key={key} style={thStyle}>{key}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {group.rows.map((item, rowIndex) => (
                <tr
                  key={rowIndex}
                  style={{
                    backgroundColor: parseFloat(item["Used PCT"]) >= 95 ? 'yellow' : 'transparent',
                  }}
                >
                  {Object.keys(item).map((key) => (
                    <td key={key} style={tdStyle}>{item[key]}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        )}

        {/* Current Active Sessions: Highlight rows where Count > 100 */}
        {group.header === "Current Active Sessions" && group.rows.length > 0 && (
          <table style={tableStyle}>
            <thead>
              <tr>
                {Object.keys(group.rows[0]).map((key) => (
                  <th key={key} style={thStyle}>{key}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {group.rows.map((item, rowIndex) => (
                <tr
                  key={rowIndex}
                  style={{
                    backgroundColor: parseInt(item["Count"], 10) > 100 ? 'yellow' : 'transparent',
                  }}
                >
                  {Object.keys(item).map((key) => (
                    <td key={key} style={tdStyle}>{item[key]}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        )}

        {/* If there's no data, show a default message */}
        {group.rows.length === 0 && (
          <div style={{ color: 'green' }}>
            <h5>No data available for {group.header}</h5>
          </div>
        )}
      </div>
    ))}
  </div>
);































const renderColumn = (columnData) => (
  <div style={{ width: '100%' }}>
    {columnData.map((group, index) => (
      <div key={index}>
        {/* Common Header */}
        <div style={headerStyle}>{group.header}</div>
        
        {/* Chart Content (if available) */}
        {chartContent && group.header.includes("Details") && (
          <StatusDoughnutChart data={chartContent} />
        )}

        {/* If the group has data (rows), highlight them in yellow */}
        {group.rows.length > 0 && (
          <table style={tableStyle}>
            <thead>
              <tr>
                {Object.keys(group.rows[0]).map((key) => (
                  <th key={key} style={thStyle}>{key}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {group.rows.map((item, rowIndex) => (
                <tr key={rowIndex} style={{ backgroundColor: 'yellow' }}>
                  {Object.keys(item).map((key) => (
                    <td key={key} style={tdStyle}>{item[key]}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        )}

        {/* Default message if no data */}
        {group.rows.length === 0 && (
          <div style={{ color: 'green' }}>
            <h5>No data available for {group.header}</h5>
          </div>
        )}
      </div>
    ))}
  </div>
);






import React, { useState } from 'react';

function DatabaseHealthCheckReports({ group, keys }) {
  // State to store the killed items based on SID
  const [killedItems, setKilledItems] = useState({});

  // Function to handle the kill process
  const killProcess = (item) => {
    // Mark the specific item as killed using its SID
    setKilledItems((prevKilledItems) => ({
      ...prevKilledItems,
      [item.SID]: true,  // Use SID as the key to disable the row's button
    }));

    // Trigger the alert after the process is marked as killed
    window.alert(`Killing process for SID: ${item.SID}`);
  };

  return (
    <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '10px' }}>
      <thead>
        <tr>
          {keys.map((key) => (
            <th
              key={key}
              style={{
                border: '1px solid #ddd',
                padding: '8px',
                backgroundColor: '#f2f2f2',
                color: '#626355',
                fontSize: '12px',
              }}
            >
              {key}
            </th>
          ))}
        </tr>
      </thead>
      <tbody>
        {group.map((item, rowIndex) => (
          <tr key={rowIndex}>
            {keys.map((key) => (
              <td
                key={key}
                style={{
                  border: '1px solid #ddd',
                  padding: '8px',
                }}
              >
                {/* Check if the key is "Action" and render the button */}
                {key === 'Action' ? (
                  <button
                    className="btn btn-primary btn-block"
                    onClick={() => killProcess(item)}
                    disabled={!!killedItems[item.SID]} // Disable button for the specific row
                  >
                    {killedItems[item.SID] ? 'Killed' : 'Kill'}
                  </button>
                ) : (
                  // Render the other column values if the key is not "Action"
                  typeof item[key] === 'number' ? item[key].toFixed(1) : item[key]
                )}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
}

export default DatabaseHealthCheckReports;


const express = require('express');
const cors = require('cors');
const cassandra = require('cassandra-driver');
const app = express();
const PORT = 5000;

// Middleware
app.use(express.json());
app.use(cors());

// POST route to execute Cassandra query with dynamic username/password
app.post('/api/executeQuery', async (req, res) => {
  const { cluster, env, dc, server, query, username, password } = req.body;

  // Validate input
  if (!cluster || !env || !dc || !server || !query || !username || !password) {
    return res.status(400).json({ error: 'All inputs (Cluster, ENV, DC, Server, Query, Username, and Password) are required' });
  }

  // Check for prohibited commands
  if (query.includes("DROP") || query.includes("DELETE")) {
    return res.status(400).json({ error: "Query contains prohibited commands (DROP, DELETE)." });
  }

  // Create a Cassandra client with the provided username and password
  const client = new cassandra.Client({
    contactPoints: ['127.0.0.1'],  // Replace with your Cassandra contact points
    localDataCenter: 'datacenter1',  // Replace with your data center
    keyspace: 'your_keyspace',  // Replace with your Cassandra keyspace
    authProvider: new cassandra.auth.PlainTextAuthProvider(username, password)  // Use the username and password from the request
  });

  // Try executing the query
  try {
    const result = await client.execute(query);
    res.json(result.rows);  // Send the query result back to the frontend
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ error: 'Error executing query' });
  }
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});









const express = require('express');
const cassandra = require('cassandra-driver');
const cors = require('cors');
const app = express();
const PORT = 5000;

// Middleware
app.use(express.json());
app.use(cors());

// Cassandra client configuration
const client = new cassandra.Client({
  contactPoints: ['127.0.0.1'], // Replace with actual Cassandra contact point
  localDataCenter: 'datacenter1', // Replace with your Cassandra Data Center
  keyspace: 'your_keyspace' // Replace with your Cassandra keyspace
});

// POST route to execute Cassandra query
app.post('/api/executeQuery', async (req, res) => {
  const { cluster, env, dc, server, query } = req.body;

  // Input validation
  if (!cluster || !env || !dc || !server || !query) {
    return res.status(400).json({ error: 'All inputs (Cluster, ENV, DC, Server, and Query) are required' });
  }

  // Check for prohibited commands
  if (query.includes("DROP") || query.includes("DELETE")) {
    return res.status(400).json({ error: "Query contains prohibited commands (DROP, DELETE)." });
  }

  // Assuming the query is valid, proceed with execution
  try {
    const result = await client.execute(query);
    res.json(result.rows);
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ error: 'Error executing query' });
  }
});

// Start the server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});








import React, { useState, useEffect } from 'react';
import axios from 'axios';
import './App.css';  // Import the CSS file

function App() {
  const [cluster, setCluster] = useState('');
  const [env, setEnv] = useState('');
  const [dc, setDc] = useState('');
  const [servers, setServers] = useState([]);
  const [selectedServer, setSelectedServer] = useState('');
  const [query, setQuery] = useState('');
  const [queryResult, setQueryResult] = useState(null);
  const [error, setError] = useState('');

  // Predefined server list (now in the frontend)
  const serverList = {
    "OR": {
      "QA1": {
        "SDC1": [
          "mcs-cass-t1-n1.ebiz.verizon.com",
          "mcs-cass-t1-n2.ebiz.verizon.com",
          "mcs-cass-t1-n3.ebiz.verizon.com",
          "mcs-cass-t1-n4.ebiz.verizon.com"
        ]
      },
      "QA2": {
        "SDC1": [
          "mcs-cass-t2-n1.ebiz.verizon.com",
          "mcs-cass-t2-n2.ebiz.verizon.com"
        ]
      }
    },
    "CART": {
      "QA1": {
        "EAST": [
          "mcs-cart-east-n1.ebiz.verizon.com",
          "mcs-cart-east-n2.ebiz.verizon.com"
        ]
      }
    }
  };

  // Fetch servers based on user selection
  useEffect(() => {
    if (cluster && env && dc) {
      const fetchedServers = serverList[cluster]?.[env]?.[dc] || [];
      setServers(fetchedServers);
      setSelectedServer('');  // Reset server selection when new servers are fetched
    }
  }, [cluster, env, dc]);

  const handleQueryExecution = async () => {
    if (!selectedServer) {
      setError('Please select a server.');
      return;
    }
    if (!query) {
      setError('Please enter a query.');
      return;
    }

    // Send the query and inputs to the backend for execution
    try {
      const response = await axios.post('http://localhost:5000/api/executeQuery', {
        cluster,
        env,
        dc,
        server: selectedServer,
        query
      });
      setQueryResult(response.data);
      setError('');
    } catch (err) {
      setError('Error executing query: ' + err.response?.data?.error || 'Unknown error');
      setQueryResult(null);
    }
  };

  return (
    <div className="App">
      <div className="container">
        <h1>Cassandra Query Executor</h1>
        <div className="form-group">
          <label>Cluster:</label>
          <select value={cluster} onChange={(e) => setCluster(e.target.value)}>
            <option value="">Select Cluster</option>
            <option value="OR">OR</option>
            <option value="CART">CART</option>
            <option value="CDN1">CDN1</option>
          </select>
        </div>
        <div className="form-group">
          <label>ENV:</label>
          <select value={env} onChange={(e) => setEnv(e.target.value)}>
            <option value="">Select ENV</option>
            <option value="QA1">QA1</option>
            <option value="QA2">QA2</option>
            <option value="QA3">QA3</option>
          </select>
        </div>
        <div className="form-group">
          <label>DC:</label>
          <select value={dc} onChange={(e) => setDc(e.target.value)}>
            <option value="">Select DC</option>
            <option value="SDC1">SDC1</option>
            <option value="EAST">EAST</option>
            <option value="WEST">WEST</option>
          </select>
        </div>

        {/* Servers Dropdown */}
        {servers.length > 0 && (
          <div className="form-group">
            <label>Servers:</label>
            <select value={selectedServer} onChange={(e) => setSelectedServer(e.target.value)}>
              <option value="">Select Server</option>
              {servers.map((server, index) => (
                <option key={index} value={server}>{server}</option>
              ))}
            </select>
          </div>
        )}

        <div className="form-group">
          <label>Query:</label>
          <textarea value={query} onChange={(e) => setQuery(e.target.value)} />
        </div>
        <button onClick={handleQueryExecution} className="btn">Execute Query</button>
        {error && <div className="error">{error}</div>}
        {queryResult && (
          <div>
            <h3>Query Result</h3>
            <table className="query-result">
              <thead>
                <tr>
                  {Object.keys(queryResult[0]).map((key, index) => (
                    <th key={index}>{key}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {queryResult.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    {Object.values(row).map((value, cellIndex) => (
                      <td key={cellIndex}>{value}</td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

export default App;











import React, { useState, useEffect } from 'react';
import './App.css';  // Import the CSS file

function App() {
  const [cluster, setCluster] = useState('');
  const [env, setEnv] = useState('');
  const [dc, setDc] = useState('');
  const [servers, setServers] = useState([]);
  const [selectedServer, setSelectedServer] = useState('');
  const [query, setQuery] = useState('');
  const [queryResult, setQueryResult] = useState(null);
  const [error, setError] = useState('');

  // Predefined server list (now in the frontend)
  const serverList = {
    "OR": {
      "QA1": {
        "SDC1": [
          "mcs-cass-t1-n1.ebiz.verizon.com",
          "mcs-cass-t1-n2.ebiz.verizon.com",
          "mcs-cass-t1-n3.ebiz.verizon.com",
          "mcs-cass-t1-n4.ebiz.verizon.com"
        ]
      },
      "QA2": {
        "SDC1": [
          "mcs-cass-t2-n1.ebiz.verizon.com",
          "mcs-cass-t2-n2.ebiz.verizon.com"
        ]
      }
    },
    "CART": {
      "QA1": {
        "EAST": [
          "mcs-cart-east-n1.ebiz.verizon.com",
          "mcs-cart-east-n2.ebiz.verizon.com"
        ]
      }
    }
  };

  // Fetch servers based on user selection
  useEffect(() => {
    if (cluster && env && dc) {
      const fetchedServers = serverList[cluster]?.[env]?.[dc] || [];
      setServers(fetchedServers);
      setSelectedServer('');  // Reset server selection when new servers are fetched
    }
  }, [cluster, env, dc]);

  const handleQueryExecution = () => {
    if (!selectedServer) {
      setError('Please select a server.');
      return;
    }
    if (!query) {
      setError('Please enter a query.');
      return;
    }

    // Mock execution result (no backend for this part)
    setError('');
    setQueryResult([{ column1: 'Sample Result 1', column2: 'Sample Result 2' }]);
  };

  return (
    <div className="App">
      <div className="container">
        <h1>Cassandra Query Executor</h1>
        <div className="form-group">
          <label>Cluster:</label>
          <select value={cluster} onChange={(e) => setCluster(e.target.value)}>
            <option value="">Select Cluster</option>
            <option value="OR">OR</option>
            <option value="CART">CART</option>
            <option value="CDN1">CDN1</option>
          </select>
        </div>
        <div className="form-group">
          <label>ENV:</label>
          <select value={env} onChange={(e) => setEnv(e.target.value)}>
            <option value="">Select ENV</option>
            <option value="QA1">QA1</option>
            <option value="QA2">QA2</option>
            <option value="QA3">QA3</option>
          </select>
        </div>
        <div className="form-group">
          <label>DC:</label>
          <select value={dc} onChange={(e) => setDc(e.target.value)}>
            <option value="">Select DC</option>
            <option value="SDC1">SDC1</option>
            <option value="EAST">EAST</option>
            <option value="WEST">WEST</option>
          </select>
        </div>

        {/* Servers Dropdown */}
        {servers.length > 0 && (
          <div className="form-group">
            <label>Servers:</label>
            <select value={selectedServer} onChange={(e) => setSelectedServer(e.target.value)}>
              <option value="">Select Server</option>
              {servers.map((server, index) => (
                <option key={index} value={server}>{server}</option>
              ))}
            </select>
          </div>
        )}

        <div className="form-group">
          <label>Query:</label>
          <textarea value={query} onChange={(e) => setQuery(e.target.value)} />
        </div>
        <button onClick={handleQueryExecution} className="btn">Execute Query</button>
        {error && <div className="error">{error}</div>}
        {queryResult && (
          <div>
            <h3>Query Result</h3>
            <table className="query-result">
              <thead>
                <tr>
                  {Object.keys(queryResult[0]).map((key, index) => (
                    <th key={index}>{key}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {queryResult.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    {Object.values(row).map((value, cellIndex) => (
                      <td key={cellIndex}>{value}</td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

export default App;














const styles = {
  chartContainer: {
    display: 'flex',
    justifyContent: 'flex-start', // Aligns everything to the left
    alignItems: 'center',         // Vertically centers items
    gap: '5px',                   // Controls space between the chart and the label
    padding: '0',                 // Removes default padding
  },
  chartWrapper: {
    width: '200px',               // Set width of the pie chart wrapper
    height: '200px',              // Set height of the pie chart wrapper
    padding: '0',                 // No padding around chart
    margin: '0',                  // Ensure no default margins
  },
  labels: {
    marginLeft: '5px',            // Reduce the space between the chart and the labels
  }
};

function StatusDoughnutChart() {
  return (
    <div style={styles.chartContainer}>
      <div style={styles.chartWrapper}>
        <DoughnutChart
          data={data}
          options={{ maintainAspectRatio: false }} // Ensures chart respects the container size
        />
      </div>
      <div style={styles.labels}>
        <h4>DB Instance Details</h4>
        {/* Add any other labels or data here */}
      </div>
    </div>
  );
}








const styles = {
  chartContainer: {
    display: 'flex',         // Enables flexbox
    justifyContent: 'flex-start', // Aligns the chart to the left
    alignItems: 'center',    // Vertically centers the chart
    paddingRight: '10px',    // Add some padding to the right of the chart
  },
  chart: {
    width: '200px',          // Set the width of the pie chart
    height: '200px',         // Set the height of the pie chart
  },
  labels: {
    marginLeft: '10px',      // Adjust the space between the pie chart and the label
  }
};

function StatusDoughnutChart() {
  return (
    <div style={styles.chartContainer}>
      <DoughnutChart
        data={data}
        width={styles.chart.width}
        height={styles.chart.height}
      />
      <div style={styles.labels}>
        <h4>DB Instance Details</h4>
        {/* Add other labels here */}
      </div>
    </div>
  );
}







.label {
  display: inline-block; /* Ensures the label is properly displayed */
  white-space: normal; /* Allows the label to wrap text */
  overflow: visible; /* Prevents text from being hidden */
  word-wrap: break-word; /* Breaks long words that may otherwise overflow */
  width: auto; /* Adjusts width automatically */
  max-width: 100%; /* Ensures it doesnâ€™t exceed the container */
}












import React from 'react';

const DatabaseDetailsTable = ({ dbDetails }) => {
    return (
        <div>
            <h2>Database Details</h2>
            <table border="1" cellPadding="10" cellSpacing="0">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Database Role</th>
                        <th>Version</th>
                        <th>Log Mode</th>
                        <th>Pluggable</th>
                    </tr>
                </thead>
                <tbody>
                    {dbDetails.map((db, index) => (
                        <tr key={index}>
                            <td>{db.NAME}</td>
                            <td>{db.DATABASE_ROLE}</td>
                            <td>{db.VERSION}</td>
                            <td>{db.LOG_MODE}</td>
                            <td>{db.PLUGGABLE}</td>
                        </tr>
                    ))}
                </tbody>
            </table>
        </div>
    );
};

// Sample data, replace this with your actual dbDetails array
const sampleDbDetails = [
    {
        NAME: "JIR2TPRD",
        DATABASE_ROLE: "PRIMARY",
        VERSION: "19.0.0.0.0",
        LOG_MODE: "ARCHIVELOG",
        PLUGGABLE: "YES"
    }
];

export default function App() {
    return (
        <div className="App">
            <DatabaseDetailsTable dbDetails={sampleDbDetails} />
        </div>
    );
}










<div className="chart-container" style={{ display: 'flex', flexDirection: 'row', gap: '20px', width: '100%', height: '500px' }}>
  <div className="rohit">
    <h3>DB Instance Details:</h3>
    <StatusPieChart pie={instanceStatusData} />
  </div>
  <div className="rohit">
    <h3>Tablespace Free And Used Analysis:</h3>
    <StatusBarChart inputData={barchart} />
  </div>
</div>






import React from 'react';
import { Bar } from 'react-chartjs-2';

export default function StatusBarChart({ data: inputData }) {

    // Prepare data for the chart
    const tablespaces = inputData.map((row, index) => ({
        TABLESPACE_NAME: row.TABLESPACE_NAME,
        TOT_SIZE_GB: (row.TOT_SIZE_MB / 1024).toFixed(2),   // Convert MB to GB and round to 2 decimals
        TOT_USED_GB: (row.TOT_USED_MB / 1024).toFixed(2),
        TOT_FREE_GB: (row.TOT_FREE_MB / 1024).toFixed(2),
        PCT_USED: row.PCT_USED
    }));

    if (!tablespaces || tablespaces.length === 0) {
        return <div>No data available</div>;
    }

    console.log(tablespaces);

    const data = {
        labels: tablespaces.map(ts => `${ts.TABLESPACE_NAME}`),
        datasets: [
            {
                label: 'Total Size (GB)',
                data: tablespaces.map(ts => ts.TOT_SIZE_GB),
                backgroundColor: 'rgba(54, 162, 235, 0.2)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1,
            },
            {
                label: 'Total Used (GB)',
                data: tablespaces.map(ts => ts.TOT_USED_GB),
                backgroundColor: 'rgba(255, 99, 132, 0.2)',
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 1,
            },
            {
                label: 'Total Free (GB)',
                data: tablespaces.map(ts => ts.TOT_FREE_GB),
                backgroundColor: 'rgba(75, 192, 192, 0.2)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1,
            }
        ]
    };

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'right',
                alignContent: 'top'
            },
            tooltip: {
                callbacks: {
                    label: function (context) {
                        const tableSpace = tablespaces[context.dataIndex];
                        return `${tableSpace.TABLESPACE_NAME} (Used: ${tableSpace.TOT_USED_GB} GB, Free: ${tableSpace.TOT_FREE_GB} GB)`;
                    }
                }
            }
        },
        scales: {
            x: {
                stacked: true,
            },
            y: {
                stacked: true,
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Size (GB)'
                }
            }
        }
    };

    return (
        <div style={{ width: '520px', height: '300px', alignContent: 'top' }}>
            <Bar className="bar" data={data} options={options} />
        </div>
    );
}











// Assume `db_pie` is the object from the first image
const db_pie = {
    metaData: [{ name: 'INSTANCE_NUMBER' }, { name: 'INSTANCE_NAME' }, { name: 'HOST_NAME' }, { name: 'STATUS' }],
    rows: [
        {
            HOST_NAME: "10.119.11.217.ebiz.verizon.com",
            INSTANCE_NAME: "nposqa4",
            INSTANCE_NUMBER: 1,
            STATUS: "OPEN"
        },
        // Add more rows as needed
    ]
};

// Convert `db_pie` data to required format
const instances = db_pie.rows.map((row, index) => ({
    INSTANCE_NUMBER: row.INSTANCE_NUMBER || index + 1,  // Assign instance number dynamically if not provided
    INSTANCE_NAME: row.INSTANCE_NAME,
    HOST_NAME: row.HOST_NAME.split('.')[0],  // Strip domain to match the second image format
    STATUS: row.STATUS
}));

// Now `instances` will be in the format similar to the second image
console.log(instances);
