// DiskValidator.js
export function validateDiskSectionLines(sectionText) {
    const requiredMounts = [
        "/app",
        "/cassandra/data",
        "/cassandra/commitlog",
        "/cassandra_logs",
        "/cmprecon"
    ];

    const lines = sectionText.split('\n').filter(line => line.trim() !== '');

    const foundMounts = [];
    const decoratedLines = lines.map(line => {
        const matchedMount = requiredMounts.find(m => line.includes(m));
        if (matchedMount) {
            foundMounts.push(matchedMount);
            return { line, isValid: true };
        } else {
            return { line, isValid: false };
        }
    });

    const missingMounts = requiredMounts.filter(m => !foundMounts.includes(m));

    return {
        decoratedLines,
        isValid: missingMounts.length === 0,
        missingMounts
    };
}

import { Card } from 'primereact/card';
import { validateDiskSectionLines } from './DiskValidator';

export default function DiskValidationCard({ logText }) {
    const result = validateDiskSectionLines(logText);

    return (
        <Card title="Disk Validation" className="shadow-4 border-round p-4 mb-4">
            {result.decoratedLines.map(({ line, isValid }, idx) => (
                <pre
                    key={idx}
                    className={`p-2 my-1 border-round text-sm ${isValid ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}
                >
                    {line}
                </pre>
            ))}
            {!result.isValid && (
                <div className="mt-3">
                    <strong className="text-red-700">Missing Mount Points:</strong>
                    <ul>
                        {result.missingMounts.map((mount, idx) => (
                            <li key={idx} className="text-red-600">- {mount}</li>
                        ))}
                    </ul>
                </div>
            )}
            {result.isValid && (
                <p className="text-green-700 mt-3 font-bold">All required mount points are present!</p>
            )}
        </Card>
    );
}




let concatenatedRows = [];
let isFirstLoop = true; // flag to track first loop

for (let i = 0; i < queries.length; i++) {
    try {
        const result = await nodeConnection.execute(queries[i]);
        if (result && Array.isArray(result.rows)) {
            
            if (isFirstLoop) {
                // First time, keep everything (header + data)
                concatenatedRows.push(...result.rows);
                isFirstLoop = false; // Set flag to false after first loop
            } else {
                // From second time onwards, skip the first row (header)
                concatenatedRows.push(...result.rows.slice(1));
            }

        }
    } catch (error) {
        console.error(`Error executing query ${i + 1}:`, error);
        throw error;
    }
}

console.log('concatenatedRows:', concatenatedRows);






import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { CheckCircle, XCircle } from 'lucide-react';

const expectedValidations = {
  disk: [
    '/app',
    '/cassandra/data',
    '/cassandra/commitlog',
    '/cassandra_logs',
    '/cmprecon',
  ],
  nproc: [
    '*      soft    nproc    4096',
    'root       soft    nproc     unlimited',
  ],
  rcLocal: [
    'echo never > /sys/kernel/mm/transparent_hugepage/defrag',
    'echo never > /sys/kernel/mm/transparent_hugepage/enabled',
    'CD_DSK=`lsblk -lno PKNAME,LABEL |grep CDATA |awk \'{print $1}\'`',
    'CTL_DSK=`lsblk -lno PKNAME,LABEL |grep CTLOG |awk \'{print $1}\'`',
    'echo 1 > /sys/block/$CD_DSK/queue/nomerges',
    'echo 1 > /sys/block/$CTL_DSK/queue/nomerges',
    'echo 16 > /sys/block/$CD_DSK/queue/read_ahead_kb',
    'echo 16 > /sys/block/$CTL_DSK/queue/read_ahead_kb',
  ],
  memlock: [
    'cassandra - memlock unlimited',
    'cassandra   - nofile 1048576',
    'cassandra   - nproc  32768',
  ],
  datastax: [
    'kernel.msgmnb=33554432',
    'kernel.msgmax=65536',
    'kernel.shmmax=33554432',
    'kernel.shmall=33554432',
    'vm.max_map_count=1048575',
    'net.ipv4.tcp_fin_timeout=30',
    'net.core.netdev_max_backlog=16384',
    'net.core.somaxconn=16384',
    'vm.swappiness=1',
    'net.core.rmem_default=1048576',
    'fs.file-max=1048576',
    'net.ipv4.tcp_keepalive_time=300',
    'vm.nr_hugepages=34400',
  ],
  sysctl: ['net.ipv4.tcp_syncookies=1'],
  crontab: ['/app/cassandra/shell/scripts/nodetoolstatus.ksh'],
};

function validateJenkinsOutput(stdoutLines) {
  const results = {};

  const includesAny = (line, items) => items.some(item => line.includes(item));

  // Disk Validation
  results.disk = expectedValidations.disk.every(expected =>
    stdoutLines.some(line => line.includes(expected))
  );

  // nproc Validation
  results.nproc = expectedValidations.nproc.every(expected =>
    stdoutLines.some(line => line.includes(expected))
  );

  // rc.local Validation
  results.rcLocal = expectedValidations.rcLocal.every(expected =>
    stdoutLines.some(line => line.includes(expected))
  );

  // memlock & nofile Validation
  results.memlock = expectedValidations.memlock.every(expected =>
    stdoutLines.some(line => line.includes(expected))
  );

  // Datastax sysctl parameters Validation
  results.datastax = expectedValidations.datastax.every(expected =>
    stdoutLines.some(line => line.includes(expected))
  );

  // sysctl.conf Validation: Must have syncookies line and then a closing ']'
  const syncookieIndex = stdoutLines.findIndex(line =>
    line.includes('net.ipv4.tcp_syncookies=1')
  );
  results.sysctl =
    syncookieIndex !== -1 &&
    stdoutLines.slice(syncookieIndex + 1).some(line => line.trim() === ']');

  // Crontab Validation
  results.crontab = stdoutLines.some(line =>
    line.includes(expectedValidations.crontab[0])
  );

  return results;
}

export default function JenkinsValidationUI({ output }) {
  const [result, setResult] = useState(null);

  const runValidation = () => {
    const validation = validateJenkinsOutput(output.stdout_lines);
    setResult(validation);
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-br from-slate-900 to-gray-800 text-white">
      <Card className="w-full max-w-3xl shadow-2xl rounded-2xl p-6 bg-slate-800 border border-slate-600">
        <CardContent>
          <h1 className="text-3xl font-bold text-center mb-6">Jenkins Output Validation</h1>
          <Button className="w-full mb-4 text-lg bg-green-600 hover:bg-green-700" onClick={runValidation}>
            Run Validation
          </Button>
          {result && (
            <div className="space-y-4 mt-6 bg-slate-700 p-4 rounded-xl shadow-lg">
              {Object.entries(result).map(([key, isValid]) => (
                <div
                  key={key}
                  className={`flex items-center justify-between p-3 rounded-xl ${
                    isValid ? 'bg-green-700' : 'bg-red-700'
                  }`}
                >
                  <span className="capitalize text-lg font-semibold">{key.replace(/([A-Z])/g, ' $1')}</span>
                  {isValid ? <CheckCircle className="text-white" /> : <XCircle className="text-white" />}
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}








1.disk validation  

first block 

true case:
"/dev/nvme5n1p1   50G   13G   38G  26% /app",

11:54:19         "/dev/nvme2n1p1  2.0T   26G  2.0T   2% /cassandra/data",

11:54:19         "/dev/nvme1n1p1  500G   27G  474G   6% /cassandra/commitlog",

11:54:19         "/dev/nvme4n1p1   50G  2.8G   48G   6% /cassandra_logs",
   "144.70.0.13:/   8.0E  6.9T  8.0E   1% /cmprecon"


false case:
ANYONE MISSED IS FALSE


2.nproc validation


true case:
  "*      soft    nproc    4096",
 "root       soft    nproc     unlimited"


false case:
ANYTHING MISSED IS FALSE


3.rc.local file validation


true case:

 "echo never > /sys/kernel/mm/transparent_hugepage/defrag",
 "echo never > /sys/kernel/mm/transparent_hugepage/enabled",

"CD_DSK=`lsblk -lno PKNAME,LABEL |grep CDATA |awk '{print $1}'`",
"CTL_DSK=`lsblk -lno PKNAME,LABEL |grep CTLOG |awk '{print $1}'`",

 "echo 1 > /sys/block/$CD_DSK/queue/nomerges"
 "echo 1 > /sys/block/$CTL_DSK/queue/nomerges",
 "echo 16 > /sys/block/$CD_DSK/queue/read_ahead_kb",
"echo 16 > /sys/block/$CTL_DSK/queue/read_ahead_kb"


false case:
ANYTHING MISSED IS FALSE


4.memlock and noflie[number of file]:

true case:
"cassandra - memlock unlimited",
 "cassandra   - nofile 1048576"

 "cassandra   - nproc  32768",


false case:
ANYTHING MISSED IS FALSE

5.Datastax recommended parameters validation

true case:
#Djerdj's suggestion
kernel.msgmnb=33554432
kernel.msgmax=65536

#Djerdj's suggestion
kernel.shmmax=33554432

#Djerdj's suggestion
kernel.shmall=33554432
vm.max_map_count=1048575

#Djerdj's suggestion:
net.ipv4.tcp_fin_timeout=30
net.core.netdev_max_backlog=16384
net.core.somaxconn=16384
net.ipv4.tcp_keepalive_intvl=10
net.ipv4.tcp_keepalive_probes=3

#(Djerdj,  review using 1)
vm.swappiness=1
net.core.rmem_default=1048576
net.core.rmem_max=67108864
net.core.wmem_default=1048576
net.core.wmem_max=67108864
net.core.optmem_max=40960
net.ipv4.tcp_rmem=4096 1048576 67108864
net.ipv4.tcp_wmem=4096 1048576 67108864
net.ipv4.tcp_slow_start_after_idle=0
net.ipv4.tcp_keepalive_time=300
net.ipv4.tcp_timestamps=0
net.ipv4.tcp_tw_reuse=1
net.ipv4.tcp_tw_recycle=1
net.ipv4.tcp_sack=0
net.ipv4.tcp_max_syn_backlog=16384

#Datastax recommendation:
fs.file-max=1048576
kernel.pid_max=200000
net.ipv4.ip_local_port_range=10000 65535
net.ipv4.tcp_window_scaling=1

# Aggressive dirty block flushing
vm.dirty_expire_centisecs=500
vm.dirty_writeback_centisecs=100
vm.dirty_background_bytes=268435456

#added on 2/9/2017 per djerdj
vm.nr_hugepages=34400
vm.hugetlb_shm_group=500



false case:
ANYTHING MISSED IS FALSE


6.SYSCTL.CONF VALIDATION:
TRUE CASE:
 "net.ipv4.tcp_syncookies=1                        # Security Requirement, CIS rhel8_3.2.8",

AFTER THIS LINE IT SHOULD BE  CLOSED "]"

FALSE CASE:
"net.ipv4.tcp_syncookies=1                        # Security Requirement, CIS rhel8_3.2.8",
ANYTHING THERE OTHER THAN CLOSED "]" IS FALSE CASE


7.crontab VALIDATION

TRUE CASE:
IF PRESENCE OF " * /app/cassandra/shell/scripts/nodetoolstatus.ksh", 

false case:

 IF absence OF " * /app/cassandra/shell/scripts/nodetoolstatus.ksh", 
<Row>
  {isdataanyshell && (
    <div
      style={{
        fontWeight: 'bold',
        display: 'flex',
        marginTop: '20px',
        fontSize: '20px',
        gap: '10px',
        color: 'purple',
        marginBottom: '20px',
      }}
    >
      {/* You can add your status or shell details here */}
    </div>
  )}

  <h2 style={{ margin: "0" }}>Nodetool Status:</h2>

  <Button 
    role="link" 
    surface="light" 
    size="small" 
    onClick={consolecall}
  >
    JENKINS CONSOLE
  </Button>

  {/* This is the storer output section */}
  <div
    style={{
      backgroundColor: '#1e1e1e',
      fontFamily: 'monospace',
      padding: '1rem',
      borderRadius: '12px',
      maxHeight: '500px',
      overflowY: 'auto',
      whiteSpace: 'pre-wrap', // handles long lines wrapping
      boxShadow: '0 4px 10px rgba(0,0,0,0.5)',
      border: '1px solid #333',
      lineHeight: '1.5',
      marginTop: '1rem'
    }}
  >
    {storer?.split('\n').map((line, index) => (
      <div key={index}>{line}</div>
    ))}
  </div>
</Row>



import React from 'react';

const ConsoleOutputViewer = ({ output }) => {
  return (
    <div
      style={{
        backgroundColor: '#1e1e1e',
        color: '#d4d4d4',
        fontFamily: 'monospace',
        padding: '1rem',
        borderRadius: '12px',
        maxHeight: '500px',
        overflowY: 'auto',
        whiteSpace: 'pre-wrap',
        boxShadow: '0 4px 10px rgba(0,0,0,0.5)',
        border: '1px solid #333',
        lineHeight: '1.5',
      }}
    >
      {output}
    </div>
  );
};

export default ConsoleOutputViewer;
function extractLastPlaybookBlock(logString) {
  const lines = logString.split('\n');
  let endIndex = -1;
  let startIndex = -1;

  // Step 1: Find the last "PLAY RECAP"
  for (let i = lines.length - 1; i >= 0; i--) {
    if (lines[i].includes('PLAY RECAP')) {
      endIndex = i;
      break;
    }
  }

  // Step 2: Find the closest "TASK [debug]" before that
  if (endIndex !== -1) {
    for (let i = endIndex; i >= 0; i--) {
      if (lines[i].includes('TASK [debug]')) {
        startIndex = i;
        break;
      }
    }
  }

  // Step 3: Return the extracted section
  if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {
    return lines.slice(startIndex, endIndex + 1).join('\n');
  } else {
    return 'No matching TASK [debug] to PLAY RECAP block found.';
  }
}






Output.push(
  <div key={index} style={{ color: "green", marginLeft: "10px", fontSize: "large", fontWeight: "700" }}>
    {group.header}
    <table key={index} style={{ width: "100%", borderCollapse: "collapse", marginTop: "10px" }}>
      <thead>
        <tr>
          {keys.map((key) => (
            <th
              key={key}
              style={{
                border: '2px solid #ddd',
                padding: '8px',
                backgroundColor: '#f2f2f2',
                color: '#620391',
                fontSize: '12px',
                textAlign: 'left !important'
              }}
            >
              {key}
            </th>
          ))}
          <th key="action-column" className="action-column table_shift_left">Action</th>
        </tr>
      </thead>
      <tbody>
        {group_rows.map((item, rowIndex) => (
          <tr key={`row-${rowIndex}`}>
            {keys.map((key) => (
              <td
                key={key}
                className={key === "Action" ? "action-column table_shift_left" : ""}
                style={{ border: '1px solid #ddd', padding: '8px', textAlign: 'left' }}
              >
                {key === "SQL_ID" ? (
                  <a
                    href="#"
                    onClick={() => handleSQLIDClick(item[key], item)}
                    style={{ color: 'blue', textDecoration: 'underline' }}
                  >
                    {item[key]}
                  </a>
                ) : (
                  typeof item[key] === 'number' && Number.isInteger(item[key]) ? item[key].toFixed(1) : item[key]
                )}
              </td>
            ))}
            <td>
              <button
                className="btn btn-primary btn-block kill-button"
                onClick={() => killProcess(item)}
                disabled={killedGties[item.SID]}
              >
                {killedGties[item.SID] ? 'killed' : 'kill'}
              </button>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  </div>
);
const handleSQLIDClick = (sqlId, item) => {
  // Custom logic to handle the SQL_ID click
  // For now just logging — you can integrate navigation or fetch as needed
  console.log("SQL ID clicked:", sqlId);
  console.log("Full Row Data:", item);

  // Optionally: navigate or highlight, or trigger a modal/dialog
};



keys.map((key) => (
  <th key={key} style={{ border: '2px solid #ddd', padding: '8px', backgroundColor: '#f2f2f2', color: '#620391', fontSize: '12px', textAlign: 'left !important' }}>{key}</th>
))

...

{group_rows.map((item, rowIndex) => (
  <tr key={`row-${rowIndex}`}>
    {keys.map((key) => (
      <td key={key} className={key === "Action" ? "action-column table_shift_left" : ""}>
        {key === "SQL_ID" ? (
          <a 
            href={`#`} 
            onClick={() => handleSQLIDClick(item[key], item)} 
            style={{ color: 'blue', textDecoration: 'underline' }}
          >
            {item[key]}
          </a>
        ) : (
          typeof item[key] === 'number' && Number.isInteger(item[key]) ? item[key].toFixed(1) : item[key]
        )}
      </td>
    ))}
    <td>
      <button className="btn btn-primary btn-block kill-button" onClick={() => killProcess(item)} disabled={killedGties[item.SID]}>
        {killedGties[item.SID] ? 'killed' : 'kill'}
      </button>
    </td>
  </tr>
))}







Thank you for your message.

This has been a long-awaited feature, and we’re happy that it’s now live. We’ve built it in a flexible way so that it’s easier to add more tasks in the future.

Right now, the next four tasks are ready, and we plan to onboard them within the next one and a half weeks. The team is now comfortable using the Jenkins console, and we’ve divided the work to make the process smoother.

We’re also preparing for the next phase, which includes five more tasks that will be added soon.

Thank you for your support.

Best regards,


Sure, I will first plan the design with Jarvis as an example and discuss it with Ram to align on the approach. Once that is finalized, I will start working on the flow and integrate it as an enhancement for future improvements. I will also incorporate some coding work to ensure a seamless implementation. Soon, I will deploy it and make it more feasible and efficient for production use.



Issue: In production, the PrimeReact Dropdown component was not displaying values correctly when using an array of arrays as options. However, it worked fine in the local environment. Instead of showing the expected values, it was returning undefined.

Possible Cause: This could be due to a version mismatch between local and production environments, affecting how PrimeReact processes nested arrays. Ideally, this issue should not have occurred, but due to an inconsistency, it did.

Fix & Deployment: To resolve this, I removed the nested array structure, ensuring the dropdown receives a simpler, more predictable data format. The fix has been deployed, and due to the monetarium, the updated code will be available in production by Monday.






<Row style={{ justifyContent: 'center', alignItems: 'center', flexDirection: 'column' }}>
  
  {/* Status Message with 3D Effect */}
  <div
    style={{
      fontWeight: 'bold',
      fontSize: '22px',
      color: 'purple',
      padding: '15px 25px',
      borderRadius: '12px',
      background: 'linear-gradient(145deg, #ffffff, #d1d1d1)',
      boxShadow: '5px 5px 10px #b8b8b8, -5px -5px 10px #ffffff',
      textAlign: 'center',
      marginBottom: '20px',
      transition: 'all 0.3s ease',
    }}
  >
    Preparing report, please hold for 1-2 mins...
  </div>

  {/* Progress Bar */}
  <div style={{ width: '80%', marginBottom: '20px' }}>
    <div
      style={{
        height: '12px',
        width: `${progress}%`,
        backgroundColor: '#4A90E2',
        borderRadius: '6px',
        transition: 'width 0.5s ease-in-out',
      }}
    ></div>
  </div>

  {/* Jenkins Console Button */}
  <Button
    role="link"
    surface="light"
    size="small"
    onClick={() => console.log('Jenkins Console Clicked')}
    disabled={!dataAvailable}
    style={{
      background: dataAvailable
        ? 'linear-gradient(145deg, #d1d1d1, #ffffff)'
        : 'linear-gradient(145deg, #e0e0e0, #c0c0c0)',
      boxShadow: dataAvailable
        ? '4px 4px 8px #b5b5b5, -4px -4px 8px #ffffff'
        : 'none',
      borderRadius: '8px',
      padding: '12px 20px',
      fontWeight: 'bold',
      color: dataAvailable ? 'black' : '#888',
      cursor: dataAvailable ? 'pointer' : 'not-allowed',
      transition: 'all 0.3s ease',
    }}
  >
    {dataAvailable ? 'Click Here to Open Jenkins Console' : 'Loading Console Button...'}
  </Button>

</Row>
<Row>
  <View
    style={{
      fontWeight: 'bold',
      display: 'flex',
      fontSize: '22px',
      gap: '15px',
      color: 'purple',
      marginBottom: '20px',
      marginTop: '20px',
      marginLeft: '40px',
      marginRight: '40px',
      padding: '15px',
      borderRadius: '10px',
      background: 'linear-gradient(145deg, #e6e6e6, #ffffff)',
      boxShadow: '5px 5px 10px #b8b8b8, -5px -5px 10px #ffffff',
    }}
  >
    <h2 style={{ margin: '0', textShadow: '1px 1px 2px rgba(0, 0, 0, 0.3)' }}>
      Preparing report, please hold for 1-2 mins...
    </h2>
  </View>

  <div>
    {display && (
      <div>
        <Button
          role="link"
          surface="light"
          size="small"
          onClick={consoleCall}
          style={{
            background: 'linear-gradient(145deg, #d1d1d1, #ffffff)',
            boxShadow: '4px 4px 8px #b5b5b5, -4px -4px 8px #ffffff',
            borderRadius: '8px',
            padding: '10px 15px',
            fontWeight: 'bold',
            transition: 'all 0.3s ease',
          }}
          onMouseEnter={(e) => {
            e.target.style.background = 'linear-gradient(145deg, #ffffff, #d1d1d1)';
          }}
          onMouseLeave={(e) => {
            e.target.style.background = 'linear-gradient(145deg, #d1d1d1, #ffffff)';
          }}
        >
          {buttonLoading ? 'Loading Console Button...' : 'Click Here to Open Jenkins Console'}
        </Button>
      </div>
    )}
  </div>
</Row>





const extractIP = (line) => {
    const ipRegex = /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g;
    const ips = line.match(ipRegex);
    return ips ? ips[0] : null; // Return first IP if found, else null
};

if (!isUnwantedLine(line)) {
    console.log("before:", line);

    let extractedIP = extractIP(line); // Extract IP first
    let cleanedLine = cleanData(line); // Process normally
    let formattedData = cleanedLine.split(/\s+/).map(cell => cell.trim());

    // If an IP was found, make sure it's at the end
    if (extractedIP) {
        formattedData.push(extractedIP);
    }

    if (formattedData.length > 1) {
        currentTable.rows.push(formattedData);
    }

    console.log("after:", formattedData);
}

<table key={index} border="1" style={{
  marginBottom: "20px",
  borderCollapse: "collapse",
  width: "100%",
  tableLayout: "fixed", // Prevents table from expanding beyond the container
  overflow: "hidden"
}}>
  <tbody>
    {table.rows.map((row, rowIndex) => (
      <tr key={rowIndex} style={{
        background: rowIndex === 0 ? "#4CAF50" : rowIndex % 2 === 0 ? "#ffffff" : "#f9f9f9",
        color: rowIndex === 0 ? "#ffffff" : "#000",
        fontWeight: rowIndex === 0 ? "bold" : "normal"
      }}>
        {row.filter(cell => cell.trim() !== "").map((cell, cellIndex) => (
          <td key={cellIndex} style={{
            padding: "8px",
            border: "1px solid #ccc",
            wordWrap: "break-word", // Ensures long text breaks
            overflowWrap: "break-word",
            whiteSpace: "normal", // Allows text to wrap properly
            maxWidth: "200px" // Set max-width to prevent overflow
          }}>
            {cell}
          </td>
        ))}
      </tr>
    ))}
  </tbody>
</table>





import React, { useState } from "react";

const DataTable = ({ tableData }) => {
  const [showModal, setShowModal] = useState(false);

  return (
    <div>
      {/* Button to open the modal */}
      <button 
        onClick={() => setShowModal(true)} 
        style={{
          padding: "10px 20px",
          background: "#007BFF",
          color: "#fff",
          border: "none",
          cursor: "pointer",
          borderRadius: "5px",
          marginBottom: "10px"
        }}
      >
        Show Data
      </button>

      {/* Modal Popup */}
      {showModal && (
        <div style={{
          position: "fixed",
          top: "0",
          left: "0",
          width: "100%",
          height: "100%",
          backgroundColor: "rgba(0, 0, 0, 0.5)",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          zIndex: "1000"
        }}>
          <div style={{
            background: "#fff",
            padding: "20px",
            width: "80%",
            maxHeight: "80vh",
            overflowY: "auto",
            borderRadius: "10px",
            boxShadow: "0 4px 8px rgba(0,0,0,0.2)"
          }}>
            {/* Close Button */}
            <button 
              onClick={() => setShowModal(false)} 
              style={{
                float: "right",
                background: "red",
                color: "#fff",
                border: "none",
                cursor: "pointer",
                padding: "5px 10px",
                borderRadius: "5px"
              }}
            >
              ✖
            </button>

            {/* Data Table */}
            {tableData.map((table, index) => (
              <table key={index} border="1" style={{
                marginBottom: "20px",
                borderCollapse: "collapse",
                width: "100%",
                tableLayout: "fixed"
              }}>
                <tbody>
                  {table.rows.map((row, rowIndex) => (
                    <tr key={rowIndex} 
                        style={{ 
                          background: rowIndex === 0 ? "#4CAF50" : rowIndex % 2 === 0 ? "#ffffff" : "#f9f9f9", 
                          color: rowIndex === 0 ? "#ffffff" : "#000",
                          fontWeight: rowIndex === 0 ? "bold" : "normal"
                        }}>
                      {row.filter(cell => cell.trim() !== "").map((cell, cellIndex) => (
                        <td key={cellIndex} style={{ padding: "8px", border: "1px solid #ccc" }}>
                          {cell}
                        </td>
                      ))}
                    </tr>
                  ))}
                </tbody>
              </table>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default DataTable;

{!loader && tableData.length > 0 && (
  <div>
    {tableData.map((table, index) => (
      <table key={index} border="1" style={{ 
        marginBottom: "20px", 
        borderCollapse: "collapse", 
        width: "100%", 
        tableLayout: "fixed" 
      }}>
        <tbody>
          {table.rows.map((row, rowIndex) => (
            <tr key={rowIndex} 
                style={{ background: rowIndex === 0 ? "#4CAF50" : rowIndex % 2 === 0 ? "#ffffff" : "#f9f9f9", 
                         color: rowIndex === 0 ? "#ffffff" : "#000",
                         fontWeight: rowIndex === 0 ? "bold" : "normal" }}>
              {row.filter(cell => cell.trim() !== "").map((cell, cellIndex) => ( // Remove empty spaces
                <td key={cellIndex} style={{ padding: "8px", border: "1px solid #ccc" }}>
                  {cell}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    ))}
  </div>
)}





{!loader && tableData.length > 0 && (
  <div>
    {tableData.map((table, index) => (
      <table key={index} border="1" style={{ 
        marginBottom: "20px", 
        borderCollapse: "collapse", 
        width: "100%", 
        tableLayout: "fixed" 
      }}>
        <thead>
          <tr style={{ background: "#f2f2f2", textAlign: "left" }}>
            {table.header.map((col, idx) => (
              <th key={idx} style={{ padding: "8px", border: "1px solid #ccc" }}>
                {col}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {table.rows.map((row, rowIndex) => (
            <tr key={rowIndex} style={{ background: rowIndex % 2 === 0 ? "#ffffff" : "#f9f9f9" }}>
              {row.filter(cell => cell.trim() !== "").map((cell, cellIndex) => ( // Remove empty spaces
                <td key={cellIndex} style={{ padding: "8px", border: "1px solid #ccc" }}>
                  {cell}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    ))}
  </div>
)}


let dashEncountered = false; // Track when "----" appears

lines.forEach((line, index) => {
    if (line.includes("----")) {
        if (!dashEncountered) {
            // First occurrence of "----", set header
            if (index > 0) {
                currentTable.header = cleanData(lines[index - 1]);
            }
            dashEncountered = true;
        } else {
            // Second occurrence of "----", table data ends
            if (currentTable.rows.length > 0) {
                tables.push(currentTable);
            }
            currentTable = { header: [], rows: [] };
            dashEncountered = false; // Reset for next table
        }
    } else if (dashEncountered) {
        // Store table rows if between "----"
        let formattedData = cleanData(line).split(/\s+/).map(cell => cell.trim());
        if (formattedData.length > 1) {
            currentTable.rows.push(formattedData);
        }
    }
});

// Push last table if not empty
if (currentTable.rows.length > 0) {
    tables.push(currentTable);
}








import React, { useState, useEffect } from "react";

const RAC_CLUSTER_STATUS = ({ rawData }) => {
    const [tableData, setTableData] = useState([]);

    useEffect(() => {
        parseData(rawData);
    }, [rawData]);

    const cleanData = (line) => {
        return line
            .replace(/[0-9;]*m/g, "")  // Remove ANSI color codes
            .replace(/[0-9]+\./g, "")  // Remove numbering (e.g., "1.")
            .replace(/.*?/g, "")   // Remove square brackets (e.g., "[data]")
            .replace(/\s{2,}/g, " ")   // Replace multiple spaces with one
            .replace(/\|/g, " ")       // Replace "|" with space if used as separator
            .trim();
    };

    const isUnwantedLine = (line) => {
        const unwantedPatterns = [
            "Resource is disabled",
            "STATUS and TARGET are different"
        ];
        return unwantedPatterns.some(pattern => line.includes(pattern));
    };

    const parseData = (text) => {
        const lines = text.split("\n");
        let tables = [];
        let currentTable = { header: [], rows: [] };
        let isHeader = true;
        let firstCase = true;
        let parsing = false;

        lines.forEach((line, index) => {
            line = line.trim();

            // Start parsing only after "TASK [Display RAC status output]"
            if (line.includes("TASK [Display RAC status output]")) {
                parsing = true;
                return;
            }

            // Stop parsing at "PLAY RECAP"
            if (line.includes("PLAY RECAP")) {
                parsing = false;
                return;
            }

            if (parsing) {
                if (line.startsWith("------")) {
                    if (firstCase) {
                        if (index > 0) {
                            currentTable.header.push(cleanData(lines[index - 1].trim()));
                        }
                        firstCase = false;
                    } else {
                        if (currentTable.header.length > 0 && currentTable.rows.length > 0) {
                            tables.push(currentTable);
                        }
                        currentTable = { header: [], rows: [] };
                        isHeader = true;
                    }
                } else if (isHeader) {
                    if (!firstCase && !isUnwantedLine(line)) {
                        currentTable.header = [cleanData(line)];
                    }
                    isHeader = false;
                } else {
                    if (!isUnwantedLine(line)) {
                        const formattedData = cleanData(line).split(" ").map(cell => cell.trim());
                        if (formattedData.length > 1) {
                            currentTable.rows.push(formattedData);
                        }
                    }
                }
            }
        });

        // Push the last table if it has valid data
        if (currentTable.header.length > 0 && currentTable.rows.length > 0) {
            tables.push(currentTable);
        }

        console.log("MAIN DATA --->", tables);
        setTableData(tables);
    };

    return (
        <div>
            {tableData.map((table, index) => (
                <table key={index} border="1" style={{ marginBottom: "20px", borderCollapse: "collapse" }}>
                    <thead>
                        <tr>
                            {table.header[0]?.split(/\s+/).map((col, idx) => (
                                <th key={idx} style={{ padding: "8px", background: "#f2f2f2" }}>{col}</th>
                            ))}
                        </tr>
                    </thead>
                    <tbody>
                        {table.rows.map((row, rowIndex) => (
                            <tr key={rowIndex}>
                                {row.map((cell, cellIndex) => (
                                    <td key={cellIndex} style={{ padding: "8px" }}>{cell}</td>
                                ))}
                            </tr>
                        ))}
                    </tbody>
                </table>
            ))}
        </div>
    );
};

export default RAC_CLUSTER_STATUS;





















const parseTables = (text) => {
    const lines = text.split("\n");
    let tables = [];
    let currentTable = { header: [], rows: [] };
    let isHeader = true;
    let firstCase = true;

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i].trim();
        
        if (line.startsWith("------")) {
            if (firstCase) {
                if (i > 0) {
                    currentTable.header.push(lines[i - 1].trim());
                }
                firstCase = false;
            } else {
                if (currentTable.header.length > 0 && currentTable.rows.length > 0) {
                    tables.push(currentTable);
                }
                currentTable = { header: [], rows: [] };
                isHeader = true;
            }
        } else if (isHeader) {
            if (!firstCase) {
                currentTable.header = [line]; 
            }
            isHeader = false;
        } else {
            if (line) currentTable.rows.push(line.split(/\s+/));
        }
    }

    if (currentTable.header.length > 0 && currentTable.rows.length > 0) {
        tables.push(currentTable);
    }

    return tables;
};

const TableRenderer = ({ text }) => {
    const tables = parseTables(text);

    return (
        <div>
            {tables.map((table, index) => (
                <table key={index} border="1" style={{ marginBottom: "20px", borderCollapse: "collapse" }}>
                    <thead>
                        <tr>
                            {table.header[0].split(/\s+/).map((col, idx) => (
                                <th key={idx} style={{ padding: "8px", background: "#f2f2f2" }}>{col}</th>
                            ))}
                        </tr>
                    </thead>
                    <tbody>
                        {table.rows.map((row, rowIndex) => (
                            <tr key={rowIndex}>
                                {row.map((cell, cellIndex) => (
                                    <td key={cellIndex} style={{ padding: "8px" }}>{cell}</td>
                                ))}
                            </tr>
                        ))}
                    </tbody>
                </table>
            ))}
        </div>
    );
};







import React, { useState } from "react";
import { Dropdown } from "primereact/dropdown"; // PrimeReact Dropdown
import { InputText } from "primereact/inputtext"; // PrimeReact Text Input

const FormInputDropdown = ({ name, options = [], onOptionChanged, disabled }) => {
    const [selectedValue, setSelectedValue] = useState(null);
    const [inputValue, setInputValue] = useState("");

    const handleDropdownChange = (e) => {
        setSelectedValue(e.value);
        setInputValue(e.value); // Update input field as well
        if (onOptionChanged) onOptionChanged(e.value);
    };

    const handleInputChange = (e) => {
        setInputValue(e.target.value);
        setSelectedValue(null); // Clear dropdown selection if user types manually
    };

    return (
        <div style={{ display: "flex", flexDirection: "column", width: "100%" }}>
            <Dropdown
                value={selectedValue}
                options={options.map(item => ({ label: item, value: item }))}
                onChange={handleDropdownChange}
                placeholder="Select an option"
                className="p-dropdown"
                disabled={disabled}
                showClear
                style={{ marginBottom: "8px" }}
            />
            <InputText
                value={inputValue}
                onChange={handleInputChange}
                placeholder="Or type manually"
                className="p-inputtext"
                disabled={disabled}
            />
        </div>
    );
};

export default FormInputDropdown;

import React from 'react';
import Select from 'react-select';
import { Controller } from 'react-hook-form';

const FormInputDropdown = (props) => {
    const {
        control,
        name,
        label,
        options = [],
        placeholder = "Select or type...",
        allowCustomInput = true,
        required = false,
        isDisabled = false
    } = props;

    return (
        <div style={{ display: 'flex', flexDirection: 'column', width: '100%' }}>
            {label && <label className="form-label">{label}</label>}
            <Controller
                name={name}
                control={control}
                rules={{ required }}
                render={({ field }) => {
                    const handleChange = (selectedOption) => {
                        if (allowCustomInput && typeof selectedOption === 'string') {
                            field.onChange({ label: selectedOption, value: selectedOption });
                        } else {
                            field.onChange(selectedOption);
                        }
                    };

                    return (
                        <Select
                            {...field}
                            options={options}
                            isClearable
                            isDisabled={isDisabled}
                            placeholder={placeholder}
                            onChange={handleChange}
                            onInputChange={(inputValue, { action }) => {
                                if (allowCustomInput && action === "input-change") {
                                    field.onChange({ label: inputValue, value: inputValue });
                                }
                            }}
                        />
                    );
                }}
            />
        </div>
    );
};

export default FormInputDropdown;











[
  {
    "tag": "general_help",
    "patterns": [
      "I need help with Oracle.",
      "Can someone assist me with Oracle Database?",
      "Where can I find help for Oracle?",
      "Who can help me with database-related issues?",
      "How can I solve my Oracle problems?",
      "Is there a guide for Oracle Database help?"
    ],
    "responses": [
      "You can consult the official Oracle documentation for help.",
      "Reach out to the Oracle support team for assistance.",
      "Try searching Oracle forums or Stack Overflow for answers.",
      "Contact your organization's DBA for Oracle-related issues.",
      "Explore Oracle tutorials available online for step-by-step guides.",
      "Use tools like SQL Developer to debug your Oracle problems.",
      "Refer to Oracle training programs to enhance your skills."
    ]
  },
  {
    "tag": "page_reference",
    "patterns": [
      "Which page should I refer to for Oracle documentation?",
      "Where can I find Oracle guides?",
      "What are the best resources for Oracle?",
      "Is there a specific site for Oracle tutorials?",
      "How can I access Oracle's online resources?",
      "Where can I find Oracle FAQs?"
    ],
    "responses": [
      "Refer to the official Oracle documentation at https://docs.oracle.com/.",
      "Oracle's developer hub offers detailed guides for all products.",
      "Visit Oracle Learning Library for free tutorials and resources.",
      "You can check Oracle forums and community pages for FAQs.",
      "Find step-by-step instructions on Oracle's YouTube channel.",
      "Use Oracle's blog for insights on new updates and best practices.",
      "Join Oracle user groups for access to shared resources."
    ]
  },
  {
    "tag": "team_reference",
    "patterns": [
      "Which team should I contact for Oracle Database issues?",
      "Who handles database-related queries?",
      "Is there a specific team for database support?",
      "Who should I talk to about Oracle performance?",
      "How do I contact the DBA team?",
      "Is there a team for Oracle troubleshooting?"
    ],
    "responses": [
      "Contact your Database Administration (DBA) team for issues.",
      "Reach out to the Oracle vendor support team for critical problems.",
      "For internal queries, connect with the database development team.",
      "Speak to your system architect for performance-related concerns.",
      "Use the Oracle Support portal to log a support ticket.",
      "Collaborate with your IT department for troubleshooting database issues.",
      "Join team meetings to discuss ongoing Oracle-related challenges."
    ]
  },
  {
    "tag": "database_choice",
    "patterns": [
      "Which database is better for my project?",
      "Should I use Oracle or MySQL?",
      "What is the best database for large-scale projects?",
      "Is Oracle suitable for small applications?",
      "What database should I use for cloud applications?",
      "How do I choose the right database for my requirements?"
    ],
    "responses": [
      "Oracle is ideal for large-scale and enterprise-level projects.",
      "MySQL is lightweight and suitable for smaller-scale applications.",
      "Consider PostgreSQL for open-source, advanced SQL features.",
      "For high availability, Oracle RAC is a great choice.",
      "Choose Oracle Autonomous Database for cloud-native solutions.",
      "Analyze your project's scalability, cost, and performance needs.",
      "Use a trial version to test the database suitability before deciding."
    ]
  },
  {
    "tag": "error_handling",
    "patterns": [
      "How do I debug Oracle errors?",
      "What should I do if I encounter ORA errors?",
      "How can I fix SQL syntax errors?",
      "What are common Oracle error codes?",
      "How do I handle runtime errors in Oracle?",
      "Is there a tool for Oracle error resolution?"
    ],
    "responses": [
      "Use Oracle SQL Developer to debug and analyze errors.",
      "Refer to the Oracle Error Messages guide for detailed solutions.",
      "Common ORA errors can be resolved by fixing syntax or permissions.",
      "Use the 'SHOW ERRORS' command to identify issues in PL/SQL code.",
      "Log errors and escalate to your DBA if needed.",
      "Check your database logs for detailed error messages.",
      "Consult Oracle support for critical or unresolved errors."
    ]
  },
  {
    "tag": "performance_tuning",
    "patterns": [
      "How can I improve database performance?",
      "What are the best practices for optimizing SQL queries?",
      "How do I reduce query execution time?",
      "What is Oracle's approach to performance tuning?",
      "How do I index a table for better performance?",
      "What tools are available for database tuning?"
    ],
    "responses": [
      "Use Oracle's Automatic Database Diagnostic Monitor (ADDM).",
      "Index your tables and avoid using SELECT * in queries.",
      "Analyze query execution plans to identify slow operations.",
      "Partition large tables to improve query performance.",
      "Use Oracle Enterprise Manager for database monitoring.",
      "Limit the use of nested queries and joins for faster execution.",
      "Regularly update database statistics to maintain performance."
    ]
  },
  {
    "tag": "tools_usage",
    "patterns": [
      "What are the tools for Oracle Database development?",
      "Which IDE is best for working with Oracle?",
      "Are there tools for Oracle query optimization?",
      "Can you recommend tools for Oracle PL/SQL development?",
      "How do I use SQL Developer with Oracle?",
      "What third-party tools work with Oracle?"
    ],
    "responses": [
      "Popular tools include Oracle SQL Developer, Toad, and PL/SQL Developer.",
      "Use Oracle Enterprise Manager for advanced database management.",
      "Try DataGrip for a third-party database IDE.",
      "SQLcl is a command-line tool for running SQL and PL/SQL scripts.",
      "DBeaver is an excellent open-source database management tool.",
      "Toad for Oracle is great for query building and optimization.",
      "Experiment with tools to find one that suits your workflow."
    ]
  },
  {
    "tag": "data_migration",
    "patterns": [
      "How do I migrate MySQL data to Oracle?",
      "What tools are available for database migration?",
      "Is there a guide for migrating data to Oracle?",
      "How do I move my database to Oracle Cloud?",
      "What is the best practice for Oracle data migration?",
      "Can I automate data migration in Oracle?"
    ],
    "responses": [
      "Use Oracle Data Pump for data migration between Oracle databases.",
      "SQL Developer supports MySQL to Oracle data migration.",
      "For cloud migration, use Oracle GoldenGate or Oracle Cloud Migration tools.",
      "Plan your migration carefully to avoid downtime.",
      "Test the migration process in a staging environment first.",
      "Follow the Oracle Database Migration Guide for best practices.",
      "Use ETL tools like Talend for advanced data migration workflows."
    ]
  },
  {
    "tag": "backup_restore",
    "patterns": [
      "How do I back up my Oracle Database?",
      "What is the process to restore data in Oracle?",
      "Can you explain database recovery methods?",
      "How does RMAN work for Oracle backups?",
      "What tools can I use for database backups?",
      "Is there an automated way to schedule backups in Oracle?"
    ],
    "responses": [
      "Use RMAN (Recovery Manager) for reliable database backups.",
      "Oracle Enterprise Manager offers backup and recovery features.",
      "Schedule regular backups using cron jobs or Oracle Scheduler.",
      "Store backups on cloud or remote servers for disaster recovery.",
      "Follow Oracle's Backup and Recovery User's Guide for detailed steps.",
      "Validate your backups regularly to ensure data integrity.",
      "Test the restoration process in a controlled environment."
    ]
  },
  {
    "tag": "version_comparison",
    "patterns": [
      "What are the differences between Oracle 11g and 19c?",
      "Which Oracle version is best for my needs?",
      "What are the key features of Oracle 19c?",
      "How does Oracle 12c compare to 19c?",
      "Should I upgrade from Oracle 11g to 19c?",
      "What are the advantages of using the latest Oracle version?"
    ],
    "responses": [
      "Oracle 19c offers better performance, scalability, and security than 11g.",
      "The 12c version introduced multitenant architecture, while 19c enhanced it.",
      "Oracle 19c includes features like JSON support and automatic indexing.",
      "19c is the long-term support release recommended for enterprises.",
      "Upgrading to 19c ensures compatibility with modern systems.",
      "Check Oracle's Release Notes for detailed version comparisons.",
      "Consider your project's needs before deciding to upgrade."
    ]
  }
]
const express = require('express');
const app = express();
const PORT = 3000;

// Middleware for parsing JSON
app.use(express.json());

// Simulated database connection function
const executeQuery = async (query) => {
    return new Promise((resolve) => setTimeout(resolve, 500)); // Simulate query delay
};

// POST endpoint to handle incoming variables and query execution
app.post('/DatabaseHealthCheckReports', async (req, res) => {
    const { var1, var2, var3, var4, var5 } = req.body; // Accept variables from frontend
    console.log("Received variables:", var1, var2, var3, var4, var5);

    const queries = Array.from({ length: 22 }, (_, i) => `SELECT * FROM table_${i + 1}`); // Example queries
    const totalQueries = queries.length;

    // Set headers for Server-Sent Events
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    try {
        for (let i = 0; i < totalQueries; i++) {
            // Simulate query execution
            await executeQuery(queries[i]);
            console.log(`Query ${i + 1} executed.`);

            // Send progress update every 5 queries
            if ((i + 1) % 5 === 0 || i + 1 === totalQueries) {
                const progress = Math.round(((i + 1) / totalQueries) * 100);
                res.write(`data: ${JSON.stringify({ progress })}\n\n`);
            }
        }

        // Send final success message
        res.write(`data: ${JSON.stringify({ progress: 100, message: "All queries executed successfully" })}\n\n`);
        res.end();
    } catch (error) {
        console.error("Error executing queries:", error);
        res.write(`data: ${JSON.stringify({ error: "An error occurred while executing queries" })}\n\n`);
        res.end();
    }
});

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});


import React, { useEffect, useState } from 'react';
import axios from 'axios';

const QueryLoader = () => {
    const [loader, setLoader] = useState("0%");
    const [variables] = useState({
        var1: "value1",
        var2: "value2",
        var3: "value3",
        var4: "value4",
        var5: "value5"
    });

    useEffect(() => {
        const fetchProgress = async () => {
            // Send the variables to the backend before establishing SSE
            await axios.post('/DatabaseHealthCheckReports', variables);

            // Initialize SSE for progress updates
            const eventSource = new EventSource('/DatabaseHealthCheckReports');

            eventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.progress) {
                    console.log(`Progress: ${data.progress}%`);
                    setLoader(`${data.progress}%`);
                }

                if (data.progress === 100) {
                    console.log("All queries executed successfully!");
                    eventSource.close();
                }

                if (data.error) {
                    console.error("Error:", data.error);
                    eventSource.close();
                }
            };

            eventSource.onerror = (error) => {
                console.error("EventSource error:", error);
                eventSource.close();
            };
        };

        fetchProgress();
    }, [variables]);

    return (
        <div>
            <h1>Query Execution Progress</h1>
            <div style={{ width: '300px', height: '30px', border: '1px solid black' }}>
                <div
                    style={{
                        width: loader,
                        height: '100%',
                        backgroundColor: 'green',
                        textAlign: 'center',
                        color: 'white',
                    }}
                >
                    {loader}
                </div>
            </div>
        </div>
    );
};

export default QueryLoader;












import React, { useState } from 'react';

const App = () => {
    const [loading, setLoading] = useState(0); // To track progress
    const [results, setResults] = useState(null); // To store the final query results

    const handleSubmit = async () => {
        try {
            const response = await fetch('http://localhost:3001/plan_change', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ /* Add payload if needed */ }),
            });

            // Check if the response body is available for streaming
            if (!response.body) {
                console.error('Streaming not supported');
                return;
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            let dataChunks = '';

            while (!done) {
                const { value, done: readerDone } = await reader.read();
                if (readerDone) {
                    done = true;
                    break;
                }

                dataChunks += decoder.decode(value, { stream: true });

                // Process the received data chunks
                const data = JSON.parse(dataChunks);
                
                // Update progress if available
                if (data.progress !== undefined) {
                    setLoading(data.progress); // Update loading based on progress value
                }

                // If the process is complete, set results
                if (data.message === 'All queries completed!') {
                    setResults(data.results);
                    setLoading(100); // Set progress to 100% when done
                }
            }
        } catch (err) {
            console.error('Error:', err);
        }
    };

    return (
        <div>
            <h1>Query Execution</h1>
            <button onClick={handleSubmit}>Start Queries</button>
            <div>
                <progress value={loading} max="100" />
                <p>{loading}% completed</p>
            </div>
            {results && (
                <div>
                    <h2>Results:</h2>
                    <ul>
                        {results.map((result, index) => (
                            <li key={index}>{result}</li>
                        ))}
                    </ul>
                </div>
            )}
        </div>
    );
};

export default App;


router.post('/plan_change', async (req, res) => {
    try {
        res.setHeader('Content-Type', 'application/json'); // Set header to JSON response
        res.setHeader('Cache-Control', 'no-cache'); // Prevent caching of responses
        res.setHeader('Connection', 'keep-alive'); // Keep the connection open

        const totalQueries = 21; // Total number of queries to process
        const batchSize = 5;     // Number of queries after which progress is updated
        let queryResults = [];   // To store results of all queries
        let progress = 0;        // Track progress

        for (let i = 1; i <= totalQueries; i++) {
            // Simulate query execution (replace this with your actual query logic)
            const result = await new Promise((resolve) => setTimeout(() => resolve(`Query ${i} result`), 500));
            queryResults.push(result);

            // Send progress update after every `batchSize` queries
            if (i % batchSize === 0 || i === totalQueries) {
                progress = Math.round((i / totalQueries) * 100); // Calculate progress as percentage
                res.write(JSON.stringify({ progress })); // Send progress update
            }
        }

        // After all queries are processed, send the final result
        res.write(JSON.stringify({ message: 'All queries completed!', progress: 100, results: queryResults }));
        res.end(); // End the response

    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});







Congratulations on your recognition! Here's a simple way to thank your manager:

"I sincerely thank my manager for the special words and encouragement on stage today. Your support and recognition mean a lot to me and motivate me to strive for even greater achievements. I'm grateful to be part of this team under your guidance."

Feel free to personalize it further based on your relationship and the context!



const oracledb = require('oracledb');
const readline = require('readline');

let connections = []; // Array to store active connections

const dbConfig = {
  user: 'tadina', // Replace with your database username
  password: 'tadina', // Replace with your database password
  connectString: 'nposqa2.ebiz.verizon.com:2055/nposqa2', // Replace with your database connection string
};

async function connectToDatabase(index) {
  try {
    // Establish a database connection
    const connection = await oracledb.getConnection(dbConfig);
    connections.push({ id: index, connection });
    console.log(`Connection ${index}: Established successfully and kept open.`);
  } catch (error) {
    console.error(`Connection ${index}: Failed - ${error.message}`);
  }
}

async function closeAllConnections() {
  try {
    for (const connEntry of connections) {
      await connEntry.connection.close();
      console.log(`Connection ${connEntry.id}: Closed successfully.`);
    }
    connections = []; // Clear all connections
    console.log('All connections closed.');
  } catch (error) {
    console.error('Failed to close all connections:', error.message);
  }
}

// Create a command-line interface for user input
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

async function main() {
  console.log('Starting to establish 10 connections...');
  for (let i = 1; i <= 10; i++) {
    await connectToDatabase(i); // Create and keep each connection open
  }
  console.log('All connections established and kept open.');
  console.log('Type "exit" to close all connections and quit the program.');

  rl.on('line', async (input) => {
    if (input.trim().toLowerCase() === 'exit') {
      console.log('Exiting program...');
      await closeAllConnections(); // Ensure all connections are closed before exiting
      rl.close();
      process.exit(0);
    } else {
      console.log('Invalid command. Type "exit" to quit.');
    }
  });
}

main();

const oracledb = require('oracledb');
const readline = require('readline');

let connections = []; // Array to store active connections

const dbConfig = {
  user: 'tadina', // Replace with your database username
  password: 'tadina', // Replace with your database password
  connectString: 'nposqa2.ebiz.verizon.com:2055/nposqa2', // Replace with your database connection string
};

async function connectToDatabase(index) {
  try {
    // Establish a database connection
    const connection = await oracledb.getConnection(dbConfig);
    connections.push({ id: index, connection });
    console.log(`Connection ${index}: Established successfully and kept open.`);
  } catch (error) {
    console.error(`Connection ${index}: Failed - ${error.message}`);
  }
}

async function closeDatabaseConnection(index) {
  try {
    const connectionEntry = connections.find((conn) => conn.id === index);
    if (connectionEntry) {
      await connectionEntry.connection.close();
      console.log(`Connection ${index}: Closed successfully.`);
      // Remove from the active connections list
      connections = connections.filter((conn) => conn.id !== index);
    } else {
      console.log(`Connection ${index}: Not found.`);
    }
  } catch (error) {
    console.error(`Failed to close connection ${index}: ${error.message}`);
  }
}

async function closeAllConnections() {
  try {
    for (const connEntry of connections) {
      await connEntry.connection.close();
      console.log(`Connection ${connEntry.id}: Closed successfully.`);
    }
    connections = []; // Clear all connections
    console.log('All connections closed.');
  } catch (error) {
    console.error('Failed to close all connections:', error.message);
  }
}

// Create a command-line interface for user input
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

async function main() {
  console.log('Starting to establish 10 connections...');
  for (let i = 1; i <= 10; i++) {
    await connectToDatabase(i); // Create and keep each connection open
  }
  console.log('All connections established and kept open.');
  console.log('Commands:');
  console.log('"close <id>" - Close a specific connection by its ID.');
  console.log('"close all" - Close all connections.');
  console.log('"exit" - Quit the program.');

  rl.on('line', async (input) => {
    const [command, arg] = input.trim().toLowerCase().split(' ');

    if (command === 'close') {
      if (arg === 'all') {
        await closeAllConnections(); // Close all connections
      } else if (!isNaN(arg)) {
        await closeDatabaseConnection(Number(arg)); // Close a specific connection
      } else {
        console.log('Invalid close command. Use "close <id>" or "close all".');
      }
    } else if (command === 'exit') {
      console.log('Exiting program...');
      await closeAllConnections(); // Ensure all connections are closed before exiting
      rl.close();
      process.exit(0);
    } else {
      console.log('Invalid command. Use "close <id>", "close all", or "exit".');
    }
  });
}

main();



const oracledb = require('oracledb');
const readline = require('readline');

let connection; // Global connection variable

async function connectToDatabase() {
  const dbConfig = {
    user: 'tadina', // Replace with your database username
    password: 'tadina', // Replace with your database password
    connectString: 'nposqa2.ebiz.verizon.com:2055/nposqa2', // Replace with your connection string
  };

  try {
    // Establish the connection
    connection = await oracledb.getConnection(dbConfig);
    console.log('Database connection established successfully.');
  } catch (error) {
    console.error('Failed to connect to the database:', error.message);
  }
}

async function closeDatabaseConnection() {
  try {
    if (connection) {
      await connection.close();
      console.log('Database connection closed successfully.');
    } else {
      console.log('No active connection to close.');
    }
  } catch (error) {
    console.error('Failed to close the database connection:', error.message);
  }
}

// Create a command-line interface for user input
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

async function main() {
  await connectToDatabase(); // Establish the connection

  console.log('Type "close" to close the database connection or "exit" to quit the program.');

  rl.on('line', async (input) => {
    if (input.trim().toLowerCase() === 'close') {
      await closeDatabaseConnection(); // Close the connection
    } else if (input.trim().toLowerCase() === 'exit') {
      console.log('Exiting program...');
      rl.close();
      process.exit(0); // Exit the process
    } else {
      console.log('Invalid command. Type "close" to close the database connection or "exit" to quit.');
    }
  });
}

main();
const oracledb = require('oracledb');

async function processNodes() {
  try {
    // Database connection configuration
    const dbConfig = {
      user: 'your_db_user',
      password: 'your_db_password',
      connectString: 'your_host:your_port/your_service_name',
    };

    // Create a database connection
    const connection = await oracledb.getConnection(dbConfig);

    // Step 1: Query all rows from `sredb.org` (or your table name)
    const fetchAllNodesQuery = `
      SELECT * 
      FROM sredb.org`;
    const result = await connection.execute(fetchAllNodesQuery);

    console.log('Fetched Nodes:', result.rows);

    // Step 2: Iterate through each row and process it individually
    for (const row of result.rows) {
      const [hostname, dbname, portnum, sqlId] = row;

      console.log(`Processing Node: Hostname=${hostname}, DBName=${dbname}, Port=${portnum}, SQL_ID=${sqlId}`);

      // Step 3: Build connection string for the current node
      const nodeConnectionString = `${hostname}:${portnum}/${dbname}`;

      // Node-specific configuration
      const nodeConfig = {
        user: 'node_user',
        password: 'node_password',
        connectString: nodeConnectionString,
      };

      try {
        // Step 4: Connect to the current node and run the query
        const nodeConnection = await oracledb.getConnection(nodeConfig);

        const planHashQuery = `
          SELECT inst_id, sql_id, plan_hash_value
          FROM gv$sql_plan
          WHERE sql_id = :sqlId`;
        const planHashResult = await nodeConnection.execute(planHashQuery, [sqlId]);

        // Step 5: Log the result for the current node
        console.log(`Results for Node ${hostname}:`);
        console.table(planHashResult.rows);

        // Close the connection for the current node
        await nodeConnection.close();
      } catch (err) {
        console.error(`Error processing node ${hostname}:`, err);
      }
    }

    // Step 6: Close the main database connection
    await connection.close();

    console.log('All nodes processed successfully.');
  } catch (err) {
    console.error('Error:', err);
  }
}

// Run the function
processNodes();



Here's a polished version of your statements for tasks that involve code-level changes and cannot be captured via screenshots:


---

SRE Portal Automation - Code-Level Tasks

1. Developed the StatusBarChart Function:

Implemented a new function to dynamically generate status bar charts, enhancing data visualization in the SRE Portal.



2. Refactored Code Logic:

Streamlined and restructured existing code to improve maintainability and execution efficiency.



3. Enhanced Error Handling:

Addressed npm package errors by introducing robust error-handling mechanisms, ensuring smoother deployments.



4. Optimized Frontend Design with CSS Improvements:

Enhanced the user interface by updating CSS to improve layout consistency and responsiveness.



5. Implemented the "Kill Disable" Functionality:

Added a critical feature to disable specific processes, ensuring better control and system reliability.



6. Resolved View Function Issues:

Debugged and fixed issues in the "View" function, ensuring seamless data retrieval and display for users.





---

Cassandra Tasks - Code-Level Work

1. Developed a 1-Hour Data Alert Mechanism:

Created a system to monitor and alert on data irregularities within a one-hour window for improved database reliability.



2. Cassandra Data Alerts Implementation:

Wrote scripts to automate alert generation based on predefined Cassandra data conditions, improving real-time monitoring.





---

These statements should effectively highlight the technical contributions you’ve made without relying on screenshots. Let me know if you'd like further refinements!


Here’s a polished and organized version of your tasks based on the content shown in the image:

SRE Portal Automation

Goal:
To automate processes that improve efficiency in Oracle DB Health Check Reports.

Tasks Completed:

1. Created the StatusBarChart function.


2. Improved logic in the code for better performance.


3. Enhanced UI alignment on the DBHealthCheck page.


4. Fixed errors in npm package extras and set up proper error handling.


5. Improved CSS for a more polished design.


6. Implemented a "Kill Disable" function.


7. Deployed DBHealthReport UI to SRE non-prod portal.


8. Successfully deployed DBHealthReport UI to SRE prod portal.


9. Resolved issues in the "View" function.


10. Added CSS button effects for improved user interaction.




---

Cassandra Tasks

1. Implemented a 1-hour data alert mechanism.


2. Developed Cassandra Data Alerts to monitor and notify on specific conditions.



Let me know if you’d like further refinements or additional categorization!



I noticed on LinkedIn that you are pursuing an M.Tech, which is something I’ve been considering as well. I’d really appreciate it if you could share some insights about the process, such as how you decided on the program, the application steps, and how you manage it alongside work.


import React, { useState } from 'react';

// Popup component with a close button and scroll bar
const Popup = ({ content, onClose }) => (
  <div style={{
    position: 'fixed', 
    top: '50%', 
    left: '50%', 
    transform: 'translate(-50%, -50%)', // Centers the popup on the screen
    width: '400px', 
    height: '300px', // Fixed size to keep it small
    padding: '20px', 
    backgroundColor: 'white', 
    border: '1px solid #ccc', 
    borderRadius: '8px',
    zIndex: 1000, 
    overflowY: 'scroll' // Enables scroll within the popup if content overflows
  }}>
    {/* Close button in the top-right corner */}
    <button 
      onClick={onClose} 
      style={{
        position: 'absolute', 
        top: '10px', 
        right: '10px', // Positions close button in top-right corner
        background: 'transparent', 
        border: 'none', 
        fontSize: '16px', 
        fontWeight: 'bold', 
        cursor: 'pointer'
      }}
    >
      &times;
    </button>
    
    <h3>Alert Log Content</h3>
    <pre>{content}</pre>
  </div>
);

function YourComponent() {
  const [isPopupVisible, setPopupVisible] = useState(false);
  const [popupContent, setPopupContent] = useState('');

  // Function to display content in the popup
  const handleViewClick = () => {
    const content = "This is the alert log content you want to display.\n\n".repeat(20); // Sample content
    setPopupContent(content);
    setPopupVisible(true);
  };

  const handleClosePopup = () => {
    setPopupVisible(false);
  };

  return (
    <div>
      <button className="download-btn">Download</button>
      <button className="view-btn" onClick={handleViewClick}>View</button>
      
      {/* Show popup if isPopupVisible is true */}
      {isPopupVisible && <Popup content={popupContent} onClose={handleClosePopup} />}
    </div>
  );
}

export default YourComponent;





import React, { useState } from 'react';

// Popup component with a close button
const Popup = ({ content, onClose }) => (
  <div style={{
    position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
    width: '400px', height: '300px', // Fixed size for the popup
    padding: '20px', backgroundColor: 'white', border: '1px solid #ccc', borderRadius: '8px',
    zIndex: 1000, overflowY: 'scroll' // Enables scroll within the popup
  }}>
    <button 
      onClick={onClose} 
      style={{
        position: 'absolute', top: '10px', right: '10px', // Position in the top-right corner
        background: 'transparent', border: 'none', fontSize: '16px', fontWeight: 'bold', cursor: 'pointer'
      }}
    >
      &times;
    </button>
    <h3>Alert Log Content</h3>
    <pre>{content}</pre>
  </div>
);

function YourComponent() {
  const [isPopupVisible, setPopupVisible] = useState(false);
  const [popupContent, setPopupContent] = useState('');

  // Function to display content in the popup
  const handleViewClick = () => {
    const content = "This is the alert log content you want to display.\n\n".repeat(20); // Sample content
    setPopupContent(content);
    setPopupVisible(true);
  };

  const handleClosePopup = () => {
    setPopupVisible(false);
  };

  return (
    <div>
      <button className="download-btn">Download</button>
      <button className="view-btn" onClick={handleViewClick}>View</button>
      
      {isPopupVisible && <Popup content={popupContent} onClose={handleClosePopup} />}
    </div>
  );
}

export default YourComponent;
import React, { useState } from 'react';

// Popup component
const Popup = ({ content, onClose }) => (
  <div style={{
    position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
    padding: '20px', backgroundColor: 'white', border: '1px solid #ccc', zIndex: 1000
  }}>
    <h3>Alert Log Content</h3>
    <pre>{content}</pre>
    <button onClick={onClose}>Close</button>
  </div>
);

function YourComponent() {
  const [isPopupVisible, setPopupVisible] = useState(false);
  const [popupContent, setPopupContent] = useState('');

  // Mock data fetch or any logic to get content for "View" button
  const handleViewClick = () => {
    const content = "This is the alert log content you want to display."; // Replace with actual fetch logic
    setPopupContent(content);
    setPopupVisible(true);
  };

  const handleClosePopup = () => {
    setPopupVisible(false);
  };

  return (
    <div>
      <button className="download-btn">Download</button>
      <button className="view-btn" onClick={handleViewClick}>View</button>
      
      {isPopupVisible && <Popup content={popupContent} onClose={handleClosePopup} />}
    </div>
  );
}

export default YourComponent;





function generateHTMLTable(alertLogData, name) {
    let table = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Alert Log Table</title>
        <style>
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid black; padding: 8px; text-align: left; }
        </style>
    </head>
    <body>
        <h2>Alert Log Data for ${name}</h2>
        <table>
            <tr>
                <th>Content</th>
            </tr>
    `;

    // Iterate through the alert log data array
    for (const entry of alertLogData) {
        if (entry["MESSAGE_TEXT"]) {
            // Extract the message content directly without the "MESSAGE_TEXT" key
            const messageContent = entry["MESSAGE_TEXT"].replace(/\n/g, '').trim();

            // Add the cleaned message content to the table row
            table += `<tr><td>${messageContent}</td></tr>`;
        }
    }

    // Close the table and HTML structure
    table += `
        </table>
    </body>
    </html>
    `;

    return table;
}





"Thank you for the appreciation! I'm glad to contribute to the team and will continue working with the same momentum, especially with the upcoming AI Slack bot project. Looking forward to more successful automation implementations in the SRE DB space."
// Function to fetch the alert log data and convert it to an HTML table
async function fetchAndDownloadAlertLogTable() {
    try {
        // Fetch the data from the backend
        const response = await axiosConfig.post('/DatabaseHealthCheckReports/db_alertlog', {
            env, cred_env, host_Name, dbName, portNum, noRecentLines
        });

        if (response.status === 200) {
            const alertLogData = response.data;  // This is the JSON data
            const tableHTML = generateHTMLTable(alertLogData);  // Generate the table HTML

            // Create a Blob with the table HTML and trigger the download as an .html file
            downloadAsHTMLFile(tableHTML, `${host_Name}_alertlog.html`);
        }
    } catch (error) {
        console.error("Error fetching data: ", error);
    }
}

// Function to generate an HTML table from JSON data
function generateHTMLTable(alertLogData) {
    // Begin HTML structure for the table
    let table = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Alert Log Table</title>
        <style>
            table { width: 100%; border-collapse: collapse; }
            th, td { border: 1px solid black; padding: 8px; text-align: left; }
        </style>
    </head>
    <body>
        <h2>Alert Log Data for ${alertLogData.ALERTLOGHOST}</h2>
        <table>
            <tr>
                <th>Parameter</th>
                <th>Message Text</th>
            </tr>`;

    // Iterate through the alert log data to fill in the rows
    for (const key in alertLogData) {
        // Check if the value is an object or array, and handle accordingly
        if (typeof alertLogData[key] === 'object') {
            if (Array.isArray(alertLogData[key])) {
                // If it's an array, we iterate over each item in the array
                alertLogData[key].forEach((item, index) => {
                    table += `<tr><td>${key} [${index}]</td><td>${JSON.stringify(item)}</td></tr>`;
                });
            } else {
                // If it's an object, we display the key-value pairs of the object
                table += `<tr><td>${key}</td><td>${JSON.stringify(alertLogData[key])}</td></tr>`;
            }
        } else {
            // Otherwise, display the simple key-value pair
            table += `<tr><td>${key}</td><td>${alertLogData[key]}</td></tr>`;
        }
    }

    // Close the table and HTML structure
    table += `
        </table>
    </body>
    </html>`;

    return table;
}

// Function to download the table HTML as a file
function downloadAsHTMLFile(htmlContent, fileName) {
    // Create a Blob with the HTML content and the MIME type 'text/html'
    const blob = new Blob([htmlContent], { type: 'text/html' });
    
    // Create a link element to trigger the download
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.href = url;
    link.download = fileName;  // Specify the filename for download
    
    // Append the link to the body and trigger the click to download the file
    document.body.appendChild(link);
    link.click();
    
    // Clean up the link element after the download is triggered
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

// Trigger the download process
fetchAndDownloadAlertLogTable();











import React, { useState } from 'react';
import axios from 'axios';

const DownloadAlertLog = () => {
  const [hostName, setHostName] = useState(''); // To store the host name

  const handleDownload = async () => {
    try {
      // Make the axios POST request (adjust the URL if needed)
      const response = await axios.post('http://localhost:5000/DatabaseHealthCheckReports/db_alertlog', {
        env: 'prod', // Assuming 'prod', adjust if needed
        cred_env: 'prod', // Adjust based on your logic
        host_Name: hostName, // The host name
        dbName: 'yourDBName', // Replace with the actual DB name
        portNum: 'yourPortNumber', // Replace with the actual port number
        noRecentLines: 'numberOfRecentLines' // Replace with the actual value
      });

      if (response.status === 200) {
        // Assuming the response data needs to be converted into a text file
        const fileData = JSON.stringify(response.data, null, 2); // Convert response data to string (pretty-printed)

        // Create a blob from the response data
        const blob = new Blob([fileData], { type: 'text/plain' });

        // Create a URL for the blob
        const url = window.URL.createObjectURL(blob);

        // Create a link element
        const link = document.createElement('a');
        link.href = url;
        link.download = `${hostName}_alertlog.txt`; // Use host name for the file name

        // Append the link to the body and trigger the download
        document.body.appendChild(link);
        link.click();

        // Remove the link after download
        document.body.removeChild(link);
      } else {
        console.error('Failed to fetch the alert log');
      }
    } catch (error) {
      console.error('Error during download', error);
    }
  };

  return (
    <div>
      <input
        type="text"
        placeholder="Enter Host Name"
        value={hostName}
        onChange={(e) => setHostName(e.target.value)}
      />
      <button onClick={handleDownload}>Download Alert Log</button>
    </div>
  );
};

export default DownloadAlertLog;




<td key={key} style={{ 
  border: '1px solid #ddd', 
  padding: '8px', 
  textAlign: key === 'Alertlog' ? 'center' : 'left' 
}}>
  {typeof item[key] === 'number' ? (
    Number.isInteger(item[key]) ? item[key] : item[key].toFixed(1)
  ) : (
    key === 'Alertlog' && (
      <button 
        style={{
          width: '60%',
          display: 'block',
          margin: '0 auto',  // Center the button horizontally
          textAlign: 'center'
        }} 
        className="btn btn-primary btn-block" 
        onClick={() => KillProcess(item)}
      >
        Download
      </button>
    )
  )}
</td>



<button
  style={{
    width: '50%',    // Adjust percentage width based on need
    margin: '0 auto', // Centers the button horizontally
    display: 'block', // Ensures the button is treated as a block element
    padding: '5px',   // Adjust the padding for a small button
    fontSize: '12px', // Adjust the font size for neatness
    textAlign: 'center' // Ensures text inside button is centered
  }}
  className="btn btn-primary btn-block"
/>



import React, { useState, useEffect } from 'react';
import axios from 'axios';
import './App.css';  // Import the CSS file

function App() {
  const [cluster, setCluster] = useState('');
  const [env, setEnv] = useState('');
  const [dc, setDc] = useState('');
  const [servers, setServers] = useState([]);
  const [selectedServer, setSelectedServer] = useState('');
  const [query, setQuery] = useState('');
  const [queryResult, setQueryResult] = useState(null);
  const [error, setError] = useState('');

  // Fetch servers automatically when cluster, env, or dc is changed
  useEffect(() => {
    const fetchServers = async () => {
      if (cluster && env && dc) { // Only fetch if all 3 are selected
        try {
          const response = await axios.post('http://localhost:5000/api/getServers', {
            cluster,
            env,
            dc
          });
          setServers(response.data);
          setSelectedServer('');  // Reset selected server when new servers are fetched
          setError('');
        } catch (err) {
          setError('Error fetching servers.');
          setServers([]);
        }
      }
    };

    fetchServers();
  }, [cluster, env, dc]); // This effect will run every time cluster, env, or dc changes

  const handleQueryExecution = async () => {
    if (!selectedServer) {
      setError('Please select a server.');
      return;
    }
    try {
      const response = await axios.post('http://localhost:5000/api/executeQuery', { query });
      setQueryResult(response.data);
      setError('');
    } catch (err) {
      setError('Error executing query: ' + err.response.data.error);
      setQueryResult(null);
    }
  };

  return (
    <div className="App">
      <div className="container">
        <h1>Cassandra Query Executor</h1>
        <div className="form-group">
          <label>Cluster:</label>
          <select value={cluster} onChange={(e) => setCluster(e.target.value)}>
            <option value="">Select Cluster</option>
            <option value="OR">OR</option>
            <option value="CART">CART</option>
            <option value="CDN1">CDN1</option>
          </select>
        </div>
        <div className="form-group">
          <label>ENV:</label>
          <select value={env} onChange={(e) => setEnv(e.target.value)}>
            <option value="">Select ENV</option>
            <option value="QA1">QA1</option>
            <option value="QA2">QA2</option>
            <option value="QA3">QA3</option>
            <option value="QA4">QA4</option>
            <option value="QA5">QA5</option>
            <option value="QA6">QA6</option>
          </select>
        </div>
        <div className="form-group">
          <label>DC:</label>
          <select value={dc} onChange={(e) => setDc(e.target.value)}>
            <option value="">Select DC</option>
            <option value="SDC1">SDC1</option>
            <option value="EAST">EAST</option>
            <option value="WEST">WEST</option>
          </select>
        </div>

        {/* Servers Dropdown */}
        {servers.length > 0 && (
          <div className="form-group">
            <label>Servers:</label>
            <select value={selectedServer} onChange={(e) => setSelectedServer(e.target.value)}>
              <option value="">Select Server</option>
              {servers.map((server, index) => (
                <option key={index} value={server}>{server}</option>
              ))}
            </select>
          </div>
        )}

        <div className="form-group">
          <label>Query:</label>
          <textarea value={query} onChange={(e) => setQuery(e.target.value)} />
        </div>
        <button onClick={handleQueryExecution} className="btn">Execute Query</button>
        {error && <div className="error">{error}</div>}
        {queryResult && (
          <div>
            <h3>Query Result</h3>
            <table className="query-result">
              <thead>
                <tr>
                  {Object.keys(queryResult[0]).map((key, index) => (
                    <th key={index}>{key}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {queryResult.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    {Object.values(row).map((value, cellIndex) => (
                      <td key={cellIndex}>{value}</td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

export default App;




import React, { useState, useEffect } from 'react';
import axios from 'axios';
import './App.css';  // Import the CSS file

function App() {
  const [cluster, setCluster] = useState('');
  const [env, setEnv] = useState('');
  const [dc, setDc] = useState('');
  const [servers, setServers] = useState([]);
  const [query, setQuery] = useState('');
  const [queryResult, setQueryResult] = useState(null);
  const [error, setError] = useState('');

  // Fetch servers automatically when cluster, env, or dc is changed
  useEffect(() => {
    const fetchServers = async () => {
      if (cluster && env && dc) { // Only fetch if all 3 are selected
        try {
          const response = await axios.post('http://localhost:5000/api/getServers', {
            cluster,
            env,
            dc
          });
          setServers(response.data);
          setError('');
        } catch (err) {
          setError('Error fetching servers.');
          setServers([]);
        }
      }
    };

    fetchServers();
  }, [cluster, env, dc]); // This effect will run every time cluster, env, or dc changes

  const handleQueryExecution = async () => {
    try {
      const response = await axios.post('http://localhost:5000/api/executeQuery', { query });
      setQueryResult(response.data);
      setError('');
    } catch (err) {
      setError('Error executing query: ' + err.response.data.error);
      setQueryResult(null);
    }
  };

  return (
    <div className="App">
      <div className="container">
        <h1>Cassandra Query Executor</h1>
        <div className="form-group">
          <label>Cluster:</label>
          <select value={cluster} onChange={(e) => setCluster(e.target.value)}>
            <option value="">Select Cluster</option>
            <option value="OR">OR</option>
            <option value="CART">CART</option>
            <option value="CDN1">CDN1</option>
          </select>
        </div>
        <div className="form-group">
          <label>ENV:</label>
          <select value={env} onChange={(e) => setEnv(e.target.value)}>
            <option value="">Select ENV</option>
            <option value="QA1">QA1</option>
            <option value="QA2">QA2</option>
            <option value="QA3">QA3</option>
            <option value="QA4">QA4</option>
            <option value="QA5">QA5</option>
            <option value="QA6">QA6</option>
          </select>
        </div>
        <div className="form-group">
          <label>DC:</label>
          <select value={dc} onChange={(e) => setDc(e.target.value)}>
            <option value="">Select DC</option>
            <option value="SDC1">SDC1</option>
            <option value="EAST">EAST</option>
            <option value="WEST">WEST</option>
          </select>
        </div>
        {servers.length > 0 && (
          <div>
            <h3>Available Servers</h3>
            <ul className="server-list">
              {servers.map((server, index) => (
                <li key={index}>{server}</li>
              ))}
            </ul>
          </div>
        )}
        <div className="form-group">
          <label>Query:</label>
          <textarea value={query} onChange={(e) => setQuery(e.target.value)} />
        </div>
        <button onClick={handleQueryExecution} className="btn">Execute Query</button>
        {error && <div className="error">{error}</div>}
        {queryResult && (
          <div>
            <h3>Query Result</h3>
            <table className="query-result">
              <thead>
                <tr>
                  {Object.keys(queryResult[0]).map((key, index) => (
                    <th key={index}>{key}</th>
                  ))}
                </tr>
              </thead>
              <tbody>
                {queryResult.map((row, rowIndex) => (
                  <tr key={rowIndex}>
                    {Object.values(row).map((value, cellIndex) => (
                      <td key={cellIndex}>{value}</td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </div>
  );
}

export default App;





* {
  box-sizing: border-box;
}

body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #f7f7f7;
}

.App {
  text-align: center;
  padding: 40px 0;
}

.container {
  background: #ffffff;
  padding: 20px;
  max-width: 800px;
  margin: 0 auto;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

h1 {
  color: #333;
  margin-bottom: 20px;
}

.form-group {
  margin-bottom: 15px;
}

label {
  display: block;
  font-weight: bold;
  margin-bottom: 5px;
}

select, textarea {
  width: 100%;
  padding: 10px;
  font-size: 16px;
  border-radius: 4px;
  border: 1px solid #ccc;
}

textarea {
  height: 100px;
}

.btn {
  padding: 10px 20px;
  background-color: #28a745;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.3s;
}

.btn:hover {
  background-color: #218838;
}

.server-list {
  text-align: left;
  margin: 20px 0;
}

.server-list li {
  background: #f1f1f1;
  padding: 10px;
  margin-bottom: 5px;
  border-radius: 4px;
}

.error {
  color: red;
  font-weight: bold;
}

.query-result {
  width: 100%;
  border-collapse: collapse;
  margin-top: 20px;
}

.query-result th, .query-result td {
  padding: 10px;
  border: 1px solid #ddd;
  text-align: left;
}

.query-result th {
  background-color: #f1f1f1;
}

.query-result tr:nth-child(even) {
  background-color: #f9f9f9;
}










import React, { useState } from 'react';
import axios from 'axios';

function App() {
  const [cluster, setCluster] = useState('');
  const [env, setEnv] = useState('');
  const [dc, setDc] = useState('');
  const [servers, setServers] = useState([]);
  const [query, setQuery] = useState('');
  const [queryResult, setQueryResult] = useState(null);
  const [error, setError] = useState('');

  const handleServerFetch = async () => {
    try {
      const response = await axios.post('http://localhost:5000/api/getServers', {
        cluster,
        env,
        dc
      });
      setServers(response.data);
      setError('');
    } catch (err) {
      setError('Error fetching servers.');
      setServers([]);
    }
  };

  const handleQueryExecution = async () => {
    try {
      const response = await axios.post('http://localhost:5000/api/executeQuery', { query });
      setQueryResult(response.data);
      setError('');
    } catch (err) {
      setError('Error executing query: ' + err.response.data.error);
      setQueryResult(null);
    }
  };

  return (
    <div className="App">
      <h1>Cassandra Query Executor</h1>
      <div>
        <label>Cluster:</label>
        <select value={cluster} onChange={(e) => setCluster(e.target.value)}>
          <option value="">Select Cluster</option>
          <option value="OR">OR</option>
          <option value="CART">CART</option>
          <option value="CDN1">CDN1</option>
          {/* Add more options based on your data */}
        </select>
      </div>
      <div>
        <label>ENV:</label>
        <select value={env} onChange={(e) => setEnv(e.target.value)}>
          <option value="">Select ENV</option>
          <option value="QA1">QA1</option>
          <option value="QA2">QA2</option>
          <option value="QA3">QA3</option>
          <option value="QA4">QA4</option>
          <option value="QA5">QA5</option>
          <option value="QA6">QA6</option>
          {/* Add more options based on your data */}
        </select>
      </div>
      <div>
        <label>DC:</label>
        <select value={dc} onChange={(e) => setDc(e.target.value)}>
          <option value="">Select DC</option>
          <option value="SDC1">SDC1</option>
          <option value="EAST">EAST</option>
          <option value="WEST">WEST</option>
          {/* Add more options based on your data */}
        </select>
      </div>
      <button onClick={handleServerFetch}>Fetch Servers</button>
      {servers.length > 0 && (
        <div>
          <h3>Available Servers</h3>
          <ul>
            {servers.map((server, index) => (
              <li key={index}>{server}</li>
            ))}
          </ul>
        </div>
      )}
      <div>
        <label>Query:</label>
        <textarea value={query} onChange={(e) => setQuery(e.target.value)} />
      </div>
      <button onClick={handleQueryExecution}>Execute Query</button>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      {queryResult && (
        <div>
          <h3>Query Result</h3>
          <table border="1">
            <thead>
              <tr>
                {Object.keys(queryResult[0]).map((key, index) => (
                  <th key={index}>{key}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {queryResult.map((row, rowIndex) => (
                <tr key={rowIndex}>
                  {Object.values(row).map((value, cellIndex) => (
                    <td key={cellIndex}>{value}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
}

export default App;




const express = require('express');
const cassandra = require('cassandra-driver');
const app = express();
const PORT = 5000;

app.use(express.json());

// Sample Data for Servers based on Cluster, ENV, and DC
const serverList = {
  "OR": {
    "QA1": {
      "SDC1": [
        "mcs-cass-t1-n3.ebiz.verizon.com",
        "mcs-cass-t1-n2.ebiz.verizon.com",
        "mcs-cass-t1-n4.ebiz.verizon.com",
        "mcs-cass-t1-n1.ebiz.verizon.com"
      ]
    }
  }
  // Add other clusters, ENV, and DC combinations here
};

// API to get servers based on Cluster, ENV, and DC
app.post('/api/getServers', (req, res) => {
  const { cluster, env, dc } = req.body;
  if (serverList[cluster] && serverList[cluster][env] && serverList[cluster][env][dc]) {
    res.json(serverList[cluster][env][dc]);
  } else {
    res.status(400).json({ error: 'Invalid Cluster, ENV, or DC' });
  }
});

// Cassandra query execution
const client = new cassandra.Client({
  contactPoints: ['127.0.0.1'], // Replace with actual contact points
  localDataCenter: 'datacenter1', // Replace with your data center
  keyspace: 'your_keyspace' // Replace with your keyspace
});

app.post('/api/executeQuery', (req, res) => {
  const { query } = req.body;
  
  // Prevent destructive queries
  if (query.includes("DROP") || query.includes("DELETE")) {
    return res.status(400).json({ error: "Query contains prohibited commands." });
  }

  client.execute(query, [], (err, result) => {
    if (err) {
      res.status(500).json({ error: 'Error executing query' });
    } else {
      res.json(result.rows);
    }
  });
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
















import { useState } from 'react';

function DatabaseHealthCheckReports(props) {
  const [killMessage, setKillMessage] = useState(''); // For alert
  const [killedItems, setKilledItems] = useState({}); // Track killed processes

  const killProcess = async (item) => {
    console.log(item.INST_ID, item.SID, item['SERIAL#']);
    
    let instId = item.INST_ID;
    let sId = item.SID;
    let serialNum = item['SERIAL#'];
    let cred_env = "";

    if (env === "AWS-PROD" || env === "ONPREM-PROD") {
      cred_env = 'prod';
    } else if (env === "AWS-NONPROD" || env === "ONPREM-NONPROD") {
      cred_env = 'non-prod';
    }

    const response = await axiosConfig.post('/DatabaseHealthCheckReports/kill_session', {
      env,
      cred_env,
      hostName,
      dbName,
      portNum,
      instId,
      sId,
      serialNum
    });

    if (response.status === 200) { // Assuming 200 is success
      setKillMessage(`Session for INST_ID: ${instId} killed successfully`);
      
      // Mark this item as killed
      setKilledItems((prevKilledItems) => ({
        ...prevKilledItems,
        [item.INST_ID]: true
      }));
      
      // Clear the message after 3 seconds
      setTimeout(() => {
        setKillMessage('');
      }, 3000);
    }
  };

  return (
    <div>
      {killMessage && <div className="alert">{killMessage}</div>}
      
      <table>
        <tbody>
          {group.map((item, rowIndex) => (
            <tr key={rowIndex}>
              {keys.map((key) => (
                <td key={key} style={{ border: '1px solid #ddd', padding: '8px' }}>
                  {typeof item[key] === 'number' ? (Number.isInteger(item[key]) ? item[key] : item[key].toFixed(1)) : item[key]}
                  {key === 'Action' && (
                    <button
                      className="btn btn-primary btn-block"
                      onClick={() => killProcess(item)}
                      disabled={killedItems[item.INST_ID]} // Disable if the item is killed
                    >
                      {killedItems[item.INST_ID] ? 'Killed' : 'Kill'}
                    </button>
                  )}
                </td>
              ))}
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}

export default DatabaseHealthCheckReports;






const tableStyle = {
    width: '100%',
    borderCollapse: 'collapse',
    marginTop: '20px',
    marginBottom: '20px'
};

const thStyle = {
    border: '1px solid #ddd',
    padding: '12px',
    backgroundColor: '#f2f2f2',
    color: '#333',
    fontSize: '16px',
    textAlign: 'center',
};

const tdStyle = {
    border: '1px solid #ddd',
    padding: '12px',
    fontSize: '14px',
    textAlign: 'center',
    wordBreak: 'break-word',  // Helps to manage long text in cells
};

const headerStyle = {
    fontWeight: 'bold',
    marginTop: '20px',
    marginBottom: '10px',
    fontSize: '18px',
    color: '#333',
    textAlign: 'left',
    padding: '10px 0',
};
